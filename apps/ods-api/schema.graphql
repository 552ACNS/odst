# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type AnswerCountAggregate {
  id: Int!
  value: Int!
  questionId: Int!
  surveyResponseId: Int!
  _all: Int!
}

type AnswerMinAggregate {
  id: String
  value: String
  questionId: String
  surveyResponseId: String
}

type AnswerMaxAggregate {
  id: String
  value: String
  questionId: String
  surveyResponseId: String
}

type RefreshToken {
  id: ID!
  user: User!
  userId: String!
  isRevoked: Boolean!
  issuedDate: DateTime!
  expiredDate: DateTime!
  hash: String!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type UserCount {
  orgs: Int!
}

type User {
  id: ID!
  email: String!
  enabled: Boolean!
  grade: String
  firstName: String!
  lastName: String!
  role: Role!
  refreshToken: RefreshToken
  orgs: [Org!]
  _count: UserCount!
}

enum Role {
  ADMIN
  DEI
  CC
}

type OrgCount {
  users: Int!
  children: Int!
  surveys: Int!
}

type Org {
  id: ID!
  name: String!
  orgTier: OrgTier!
  users: [User!]
  parentId: String
  parent: Org
  children: [Org!]
  surveys: [Survey!]
  _count: OrgCount!
}

enum OrgTier {
  WING
  GROUP
  SQUADRON
  OTHER
}

type SurveyResponseCount {
  answers: Int!
}

type SurveyResponse {
  id: ID!
  survey: Survey!
  surveyId: String!
  openedDate: DateTime!
  closedDate: DateTime
  answers: [Answer!]
  routeOutside: Boolean!
  resolution: String
  _count: SurveyResponseCount!
}

type SurveyCount {
  orgs: Int!
  questions: Int!
  surveyResponses: Int!
}

type Survey {
  id: ID!
  orgs: [Org!]
  questions: [Question!]
  questionsHash: String
  surveyResponses: [SurveyResponse!]
  _count: SurveyCount!
}

type QuestionCount {
  surveys: Int!
  answers: Int!
}

type Question {
  id: ID!
  prompt: String!
  surveys: [Survey!]
  answers: [Answer!]
  _count: QuestionCount!
}

type Answer {
  id: ID!
  value: String!
  question: Question!
  questionId: String!
  surveyResponse: SurveyResponse!
  surveyResponseId: String!
}

type OrgCountAggregate {
  id: Int!
  name: Int!
  orgTier: Int!
  parentId: Int!
  _all: Int!
}

type OrgMinAggregate {
  id: String
  name: String
  orgTier: OrgTier
  parentId: String
}

type OrgMaxAggregate {
  id: String
  name: String
  orgTier: OrgTier
  parentId: String
}

type QuestionCountAggregate {
  id: Int!
  prompt: Int!
  _all: Int!
}

type QuestionMinAggregate {
  id: String
  prompt: String
}

type QuestionMaxAggregate {
  id: String
  prompt: String
}

type RefreshTokenCountAggregate {
  id: Int!
  userId: Int!
  isRevoked: Int!
  issuedDate: Int!
  expiredDate: Int!
  hash: Int!
  _all: Int!
}

type RefreshTokenMinAggregate {
  id: String
  userId: String
  isRevoked: Boolean
  issuedDate: DateTime
  expiredDate: DateTime
  hash: String
}

type RefreshTokenMaxAggregate {
  id: String
  userId: String
  isRevoked: Boolean
  issuedDate: DateTime
  expiredDate: DateTime
  hash: String
}

type SurveyCountAggregate {
  id: Int!
  questionsHash: Int!
  _all: Int!
}

type SurveyMinAggregate {
  id: String
  questionsHash: String
}

type SurveyMaxAggregate {
  id: String
  questionsHash: String
}

type SurveyResponseCountAggregate {
  id: Int!
  surveyId: Int!
  openedDate: Int!
  closedDate: Int!
  routeOutside: Int!
  resolution: Int!
  _all: Int!
}

type SurveyResponseMinAggregate {
  id: String
  surveyId: String
  openedDate: DateTime
  closedDate: DateTime
  routeOutside: Boolean
  resolution: String
}

type SurveyResponseMaxAggregate {
  id: String
  surveyId: String
  openedDate: DateTime
  closedDate: DateTime
  routeOutside: Boolean
  resolution: String
}

type UserCountAggregate {
  id: Int!
  email: Int!
  enabled: Int!
  grade: Int!
  firstName: Int!
  lastName: Int!
  role: Int!
  _all: Int!
}

type UserMinAggregate {
  id: String
  email: String
  enabled: Boolean
  grade: String
  firstName: String
  lastName: String
  role: Role
}

type UserMaxAggregate {
  id: String
  email: String
  enabled: Boolean
  grade: String
  firstName: String
  lastName: String
  role: Role
}

type Tokens {
  accessToken: String!
  refreshToken: String!
}

type ResponseCount {
  unresolved: Float!
  overdue: Float!
  resolved: Float!
}

type Query {
  findManySurveys: [Survey!]!
  findUniqueSurvey(surveyWhereUniqueInput: SurveyWhereUniqueInput!): Survey!
  findManySurveyResponses(where: SurveyResponseWhereInput, orderBy: [SurveyResponseOrderByWithRelationInput!], cursor: SurveyResponseWhereUniqueInput, take: Int, skip: Int, distinct: [SurveyResponseScalarFieldEnum!]): [SurveyResponse!]!
  findUniqueSurveyResponse(surveyResponseWhereUniqueInput: SurveyResponseWhereUniqueInput!): SurveyResponse!
  getResponseCount(where: SurveyResponseWhereInput, orderBy: [SurveyResponseOrderByWithRelationInput!], cursor: SurveyResponseWhereUniqueInput, take: Int, skip: Int, _count: SurveyResponseCountAggregateInput, _min: SurveyResponseMinAggregateInput, _max: SurveyResponseMaxAggregateInput): Int!
  ResponseCount: ResponseCount!
  getIssuesByStatus(resolved: String!): [String!]!
  findManyAnswers: [Answer!]!
  findUniqueAnswer(answerWhereUniqueInput: AnswerWhereUniqueInput!): Answer!
  findManyOrgs: [Org!]!
  getSubOrgs(orgWhereUniqueInput: OrgWhereUniqueInput!): [Org!]!
  findUniqueOrg(orgWhereUniqueInput: OrgWhereUniqueInput!): Org!
  findManyQuestions: [Question!]!
  getSubQuestions(surveyWhereUniqueInput: SurveyWhereUniqueInput!): [Question!]!
  findUniqueQuestion(questionWhereUniqueInput: QuestionWhereUniqueInput!): Question!
  findUsersWithRole(role: String!): [User!]!
  findManyUsers(where: UserWhereInput, orderBy: [UserOrderByWithRelationInput!], cursor: UserWhereUniqueInput, take: Int, skip: Int, distinct: [UserScalarFieldEnum!]): [User!]!
  getCommanders: [User!]!
  me: User!
  usernameOrEmailExists(usernameOrEmail: String!): Boolean!
}

input SurveyWhereUniqueInput {
  id: String
  questionsHash: String
}

input SurveyResponseWhereInput {
  AND: [SurveyResponseWhereInput!]
  OR: [SurveyResponseWhereInput!]
  NOT: [SurveyResponseWhereInput!]
  id: StringFilter
  survey: SurveyRelationFilter
  surveyId: StringFilter
  openedDate: DateTimeFilter
  closedDate: DateTimeNullableFilter
  answers: AnswerListRelationFilter
  routeOutside: BoolFilter
  resolution: StringNullableFilter
}

input StringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringFilter
}

enum QueryMode {
  default
  insensitive
}

input NestedStringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringFilter
}

input SurveyRelationFilter {
  is: SurveyWhereInput
  isNot: SurveyWhereInput
}

input SurveyWhereInput {
  AND: [SurveyWhereInput!]
  OR: [SurveyWhereInput!]
  NOT: [SurveyWhereInput!]
  id: StringFilter
  orgs: OrgListRelationFilter
  questions: QuestionListRelationFilter
  questionsHash: StringNullableFilter
  surveyResponses: SurveyResponseListRelationFilter
}

input OrgListRelationFilter {
  every: OrgWhereInput
  some: OrgWhereInput
  none: OrgWhereInput
}

input OrgWhereInput {
  AND: [OrgWhereInput!]
  OR: [OrgWhereInput!]
  NOT: [OrgWhereInput!]
  id: StringFilter
  name: StringFilter
  orgTier: EnumOrgTierFilter
  users: UserListRelationFilter
  parentId: StringNullableFilter
  parent: OrgRelationFilter
  children: OrgListRelationFilter
  surveys: SurveyListRelationFilter
}

input EnumOrgTierFilter {
  equals: OrgTier
  in: [OrgTier!]
  notIn: [OrgTier!]
  not: NestedEnumOrgTierFilter
}

input NestedEnumOrgTierFilter {
  equals: OrgTier
  in: [OrgTier!]
  notIn: [OrgTier!]
  not: NestedEnumOrgTierFilter
}

input UserListRelationFilter {
  every: UserWhereInput
  some: UserWhereInput
  none: UserWhereInput
}

input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
  id: StringFilter
  email: StringFilter
  password: StringFilter
  enabled: BoolFilter
  grade: StringNullableFilter
  firstName: StringFilter
  lastName: StringFilter
  role: EnumRoleFilter
  refreshToken: RefreshTokenRelationFilter
  orgs: OrgListRelationFilter
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input StringNullableFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringNullableFilter
}

input NestedStringNullableFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringNullableFilter
}

input EnumRoleFilter {
  equals: Role
  in: [Role!]
  notIn: [Role!]
  not: NestedEnumRoleFilter
}

input NestedEnumRoleFilter {
  equals: Role
  in: [Role!]
  notIn: [Role!]
  not: NestedEnumRoleFilter
}

input RefreshTokenRelationFilter {
  is: RefreshTokenWhereInput
  isNot: RefreshTokenWhereInput
}

input RefreshTokenWhereInput {
  AND: [RefreshTokenWhereInput!]
  OR: [RefreshTokenWhereInput!]
  NOT: [RefreshTokenWhereInput!]
  id: StringFilter
  user: UserRelationFilter
  userId: StringFilter
  isRevoked: BoolFilter
  issuedDate: DateTimeFilter
  expiredDate: DateTimeFilter
  hash: StringFilter
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

input DateTimeFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: NestedDateTimeFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: NestedDateTimeFilter
}

input OrgRelationFilter {
  is: OrgWhereInput
  isNot: OrgWhereInput
}

input SurveyListRelationFilter {
  every: SurveyWhereInput
  some: SurveyWhereInput
  none: SurveyWhereInput
}

input QuestionListRelationFilter {
  every: QuestionWhereInput
  some: QuestionWhereInput
  none: QuestionWhereInput
}

input QuestionWhereInput {
  AND: [QuestionWhereInput!]
  OR: [QuestionWhereInput!]
  NOT: [QuestionWhereInput!]
  id: StringFilter
  prompt: StringFilter
  surveys: SurveyListRelationFilter
  answers: AnswerListRelationFilter
}

input AnswerListRelationFilter {
  every: AnswerWhereInput
  some: AnswerWhereInput
  none: AnswerWhereInput
}

input AnswerWhereInput {
  AND: [AnswerWhereInput!]
  OR: [AnswerWhereInput!]
  NOT: [AnswerWhereInput!]
  id: StringFilter
  value: StringFilter
  question: QuestionRelationFilter
  questionId: StringFilter
  surveyResponse: SurveyResponseRelationFilter
  surveyResponseId: StringFilter
}

input QuestionRelationFilter {
  is: QuestionWhereInput
  isNot: QuestionWhereInput
}

input SurveyResponseRelationFilter {
  is: SurveyResponseWhereInput
  isNot: SurveyResponseWhereInput
}

input SurveyResponseListRelationFilter {
  every: SurveyResponseWhereInput
  some: SurveyResponseWhereInput
  none: SurveyResponseWhereInput
}

input DateTimeNullableFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: NestedDateTimeNullableFilter
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: NestedDateTimeNullableFilter
}

input SurveyResponseOrderByWithRelationInput {
  id: SortOrder
  survey: SurveyOrderByWithRelationInput
  surveyId: SortOrder
  openedDate: SortOrder
  closedDate: SortOrder
  answers: AnswerOrderByRelationAggregateInput
  routeOutside: SortOrder
  resolution: SortOrder
}

enum SortOrder {
  asc
  desc
}

input SurveyOrderByWithRelationInput {
  id: SortOrder
  orgs: OrgOrderByRelationAggregateInput
  questions: QuestionOrderByRelationAggregateInput
  questionsHash: SortOrder
  surveyResponses: SurveyResponseOrderByRelationAggregateInput
}

input OrgOrderByRelationAggregateInput {
  _count: SortOrder
}

input QuestionOrderByRelationAggregateInput {
  _count: SortOrder
}

input SurveyResponseOrderByRelationAggregateInput {
  _count: SortOrder
}

input AnswerOrderByRelationAggregateInput {
  _count: SortOrder
}

input SurveyResponseWhereUniqueInput {
  id: String
}

enum SurveyResponseScalarFieldEnum {
  id
  surveyId
  openedDate
  closedDate
  routeOutside
  resolution
}

input SurveyResponseCountAggregateInput {
  id: Boolean
  surveyId: Boolean
  openedDate: Boolean
  closedDate: Boolean
  routeOutside: Boolean
  resolution: Boolean
  _all: Boolean
}

input SurveyResponseMinAggregateInput {
  id: Boolean
  surveyId: Boolean
  openedDate: Boolean
  closedDate: Boolean
  routeOutside: Boolean
  resolution: Boolean
}

input SurveyResponseMaxAggregateInput {
  id: Boolean
  surveyId: Boolean
  openedDate: Boolean
  closedDate: Boolean
  routeOutside: Boolean
  resolution: Boolean
}

input AnswerWhereUniqueInput {
  id: String
}

input OrgWhereUniqueInput {
  id: String
  name: String
}

input QuestionWhereUniqueInput {
  id: String
  prompt: String
}

input UserOrderByWithRelationInput {
  id: SortOrder
  email: SortOrder
  password: SortOrder
  enabled: SortOrder
  grade: SortOrder
  firstName: SortOrder
  lastName: SortOrder
  role: SortOrder
  refreshToken: RefreshTokenOrderByWithRelationInput
  orgs: OrgOrderByRelationAggregateInput
}

input RefreshTokenOrderByWithRelationInput {
  id: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
  isRevoked: SortOrder
  issuedDate: SortOrder
  expiredDate: SortOrder
  hash: SortOrder
}

input UserWhereUniqueInput {
  id: String
  email: String
}

enum UserScalarFieldEnum {
  id
  email
  password
  enabled
  grade
  firstName
  lastName
  role
}

type Mutation {
  createSurveyWithQuestions(questionPrompts: [String!]!, orgWhereUniqueInput: OrgWhereUniqueInput!): Survey!
  createSurvey(surveyCreateInput: SurveyCreateInput!): Survey!
  updateSurvey(SurveyWhereUniqueInput: SurveyWhereUniqueInput!, SurveyUpdateInput: SurveyUpdateInput!): Survey!
  deleteSurvey(surveyWhereUniqueInput: SurveyWhereUniqueInput!): Survey!
  createSurveyResponse(surveyResponseCreateInput: SurveyResponseCreateInput!): SurveyResponse!
  updateSurveyResponse(SurveyResponseWhereUniqueInput: SurveyResponseWhereUniqueInput!, SurveyResponseUpdateInput: SurveyResponseUpdateInput!): SurveyResponse!
  deleteSurveyResponse(surveyResponseWhereUniqueInput: SurveyResponseWhereUniqueInput!): SurveyResponse!
  createAnswer(answerCreateInput: AnswerCreateInput!): Answer!
  createOrg(orgCreateInput: OrgCreateInput!): Org!
  updateOrg(OrgWhereUniqueInput: OrgWhereUniqueInput!, OrgUpdateInput: OrgUpdateInput!): Org!
  deleteOrg(orgWhereUniqueInput: OrgWhereUniqueInput!): Org!
  createQuestion(questionCreateInput: QuestionCreateInput!): Question!
  updateQuestion(QuestionWhereUniqueInput: QuestionWhereUniqueInput!, QuestionUpdateInput: QuestionUpdateInput!): Question!
  createUser(userCreateInput: UserCreateInput!): User!
  deleteUser(userWhereUniqueInput: UserWhereUniqueInput!): User
  login(loginUserInput: LoginUserInput!): Tokens!
  refreshTokens(refreshLoginInput: RefreshLoginInput!): Tokens!
}

input SurveyCreateInput {
  id: String
  orgs: OrgCreateNestedManyWithoutSurveysInput
  questions: QuestionCreateNestedManyWithoutSurveysInput
  questionsHash: String
  surveyResponses: SurveyResponseCreateNestedManyWithoutSurveyInput
}

input OrgCreateNestedManyWithoutSurveysInput {
  create: [OrgCreateWithoutSurveysInput!]
  connectOrCreate: [OrgCreateOrConnectWithoutSurveysInput!]
  connect: [OrgWhereUniqueInput!]
}

input OrgCreateWithoutSurveysInput {
  id: String
  name: String!
  orgTier: OrgTier!
  users: UserCreateNestedManyWithoutOrgsInput
  parent: OrgCreateNestedOneWithoutChildrenInput
  children: OrgCreateNestedManyWithoutParentInput
}

input UserCreateNestedManyWithoutOrgsInput {
  create: [UserCreateWithoutOrgsInput!]
  connectOrCreate: [UserCreateOrConnectWithoutOrgsInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateWithoutOrgsInput {
  id: String
  email: String!
  password: String!
  enabled: Boolean
  grade: String
  firstName: String!
  lastName: String!
  role: Role!
  refreshToken: RefreshTokenCreateNestedOneWithoutUserInput
}

input RefreshTokenCreateNestedOneWithoutUserInput {
  create: RefreshTokenCreateWithoutUserInput
  connectOrCreate: RefreshTokenCreateOrConnectWithoutUserInput
  connect: RefreshTokenWhereUniqueInput
}

input RefreshTokenCreateWithoutUserInput {
  id: String
  isRevoked: Boolean
  issuedDate: DateTime
  expiredDate: DateTime!
  hash: String!
}

input RefreshTokenCreateOrConnectWithoutUserInput {
  where: RefreshTokenWhereUniqueInput!
  create: RefreshTokenCreateWithoutUserInput!
}

input RefreshTokenWhereUniqueInput {
  id: String
  userId: String
}

input UserCreateOrConnectWithoutOrgsInput {
  where: UserWhereUniqueInput!
  create: UserCreateWithoutOrgsInput!
}

input OrgCreateNestedOneWithoutChildrenInput {
  create: OrgCreateWithoutChildrenInput
  connectOrCreate: OrgCreateOrConnectWithoutChildrenInput
  connect: OrgWhereUniqueInput
}

input OrgCreateWithoutChildrenInput {
  id: String
  name: String!
  orgTier: OrgTier!
  users: UserCreateNestedManyWithoutOrgsInput
  parent: OrgCreateNestedOneWithoutChildrenInput
  surveys: SurveyCreateNestedManyWithoutOrgsInput
}

input SurveyCreateNestedManyWithoutOrgsInput {
  create: [SurveyCreateWithoutOrgsInput!]
  connectOrCreate: [SurveyCreateOrConnectWithoutOrgsInput!]
  connect: [SurveyWhereUniqueInput!]
}

input SurveyCreateWithoutOrgsInput {
  id: String
  questions: QuestionCreateNestedManyWithoutSurveysInput
  questionsHash: String
  surveyResponses: SurveyResponseCreateNestedManyWithoutSurveyInput
}

input QuestionCreateNestedManyWithoutSurveysInput {
  create: [QuestionCreateWithoutSurveysInput!]
  connectOrCreate: [QuestionCreateOrConnectWithoutSurveysInput!]
  connect: [QuestionWhereUniqueInput!]
}

input QuestionCreateWithoutSurveysInput {
  id: String
  prompt: String!
  answers: AnswerCreateNestedManyWithoutQuestionInput
}

input AnswerCreateNestedManyWithoutQuestionInput {
  create: [AnswerCreateWithoutQuestionInput!]
  connectOrCreate: [AnswerCreateOrConnectWithoutQuestionInput!]
  createMany: AnswerCreateManyQuestionInputEnvelope
  connect: [AnswerWhereUniqueInput!]
}

input AnswerCreateWithoutQuestionInput {
  id: String
  value: String!
  surveyResponse: SurveyResponseCreateNestedOneWithoutAnswersInput!
}

input SurveyResponseCreateNestedOneWithoutAnswersInput {
  create: SurveyResponseCreateWithoutAnswersInput
  connectOrCreate: SurveyResponseCreateOrConnectWithoutAnswersInput
  connect: SurveyResponseWhereUniqueInput
}

input SurveyResponseCreateWithoutAnswersInput {
  id: String
  survey: SurveyCreateNestedOneWithoutSurveyResponsesInput!
  openedDate: DateTime
  closedDate: DateTime
  routeOutside: Boolean
  resolution: String
}

input SurveyCreateNestedOneWithoutSurveyResponsesInput {
  create: SurveyCreateWithoutSurveyResponsesInput
  connectOrCreate: SurveyCreateOrConnectWithoutSurveyResponsesInput
  connect: SurveyWhereUniqueInput
}

input SurveyCreateWithoutSurveyResponsesInput {
  id: String
  orgs: OrgCreateNestedManyWithoutSurveysInput
  questions: QuestionCreateNestedManyWithoutSurveysInput
  questionsHash: String
}

input SurveyCreateOrConnectWithoutSurveyResponsesInput {
  where: SurveyWhereUniqueInput!
  create: SurveyCreateWithoutSurveyResponsesInput!
}

input SurveyResponseCreateOrConnectWithoutAnswersInput {
  where: SurveyResponseWhereUniqueInput!
  create: SurveyResponseCreateWithoutAnswersInput!
}

input AnswerCreateOrConnectWithoutQuestionInput {
  where: AnswerWhereUniqueInput!
  create: AnswerCreateWithoutQuestionInput!
}

input AnswerCreateManyQuestionInputEnvelope {
  data: [AnswerCreateManyQuestionInput!]!
  skipDuplicates: Boolean
}

input AnswerCreateManyQuestionInput {
  id: String
  value: String!
  surveyResponseId: String!
}

input QuestionCreateOrConnectWithoutSurveysInput {
  where: QuestionWhereUniqueInput!
  create: QuestionCreateWithoutSurveysInput!
}

input SurveyResponseCreateNestedManyWithoutSurveyInput {
  create: [SurveyResponseCreateWithoutSurveyInput!]
  connectOrCreate: [SurveyResponseCreateOrConnectWithoutSurveyInput!]
  createMany: SurveyResponseCreateManySurveyInputEnvelope
  connect: [SurveyResponseWhereUniqueInput!]
}

input SurveyResponseCreateWithoutSurveyInput {
  id: String
  openedDate: DateTime
  closedDate: DateTime
  answers: AnswerCreateNestedManyWithoutSurveyResponseInput
  routeOutside: Boolean
  resolution: String
}

input AnswerCreateNestedManyWithoutSurveyResponseInput {
  create: [AnswerCreateWithoutSurveyResponseInput!]
  connectOrCreate: [AnswerCreateOrConnectWithoutSurveyResponseInput!]
  createMany: AnswerCreateManySurveyResponseInputEnvelope
  connect: [AnswerWhereUniqueInput!]
}

input AnswerCreateWithoutSurveyResponseInput {
  id: String
  value: String!
  question: QuestionCreateNestedOneWithoutAnswersInput!
}

input QuestionCreateNestedOneWithoutAnswersInput {
  create: QuestionCreateWithoutAnswersInput
  connectOrCreate: QuestionCreateOrConnectWithoutAnswersInput
  connect: QuestionWhereUniqueInput
}

input QuestionCreateWithoutAnswersInput {
  id: String
  prompt: String!
  surveys: SurveyCreateNestedManyWithoutQuestionsInput
}

input SurveyCreateNestedManyWithoutQuestionsInput {
  create: [SurveyCreateWithoutQuestionsInput!]
  connectOrCreate: [SurveyCreateOrConnectWithoutQuestionsInput!]
  connect: [SurveyWhereUniqueInput!]
}

input SurveyCreateWithoutQuestionsInput {
  id: String
  orgs: OrgCreateNestedManyWithoutSurveysInput
  questionsHash: String
  surveyResponses: SurveyResponseCreateNestedManyWithoutSurveyInput
}

input SurveyCreateOrConnectWithoutQuestionsInput {
  where: SurveyWhereUniqueInput!
  create: SurveyCreateWithoutQuestionsInput!
}

input QuestionCreateOrConnectWithoutAnswersInput {
  where: QuestionWhereUniqueInput!
  create: QuestionCreateWithoutAnswersInput!
}

input AnswerCreateOrConnectWithoutSurveyResponseInput {
  where: AnswerWhereUniqueInput!
  create: AnswerCreateWithoutSurveyResponseInput!
}

input AnswerCreateManySurveyResponseInputEnvelope {
  data: [AnswerCreateManySurveyResponseInput!]!
  skipDuplicates: Boolean
}

input AnswerCreateManySurveyResponseInput {
  id: String
  value: String!
  questionId: String!
}

input SurveyResponseCreateOrConnectWithoutSurveyInput {
  where: SurveyResponseWhereUniqueInput!
  create: SurveyResponseCreateWithoutSurveyInput!
}

input SurveyResponseCreateManySurveyInputEnvelope {
  data: [SurveyResponseCreateManySurveyInput!]!
  skipDuplicates: Boolean
}

input SurveyResponseCreateManySurveyInput {
  id: String
  openedDate: DateTime
  closedDate: DateTime
  routeOutside: Boolean
  resolution: String
}

input SurveyCreateOrConnectWithoutOrgsInput {
  where: SurveyWhereUniqueInput!
  create: SurveyCreateWithoutOrgsInput!
}

input OrgCreateOrConnectWithoutChildrenInput {
  where: OrgWhereUniqueInput!
  create: OrgCreateWithoutChildrenInput!
}

input OrgCreateNestedManyWithoutParentInput {
  create: [OrgCreateWithoutParentInput!]
  connectOrCreate: [OrgCreateOrConnectWithoutParentInput!]
  createMany: OrgCreateManyParentInputEnvelope
  connect: [OrgWhereUniqueInput!]
}

input OrgCreateWithoutParentInput {
  id: String
  name: String!
  orgTier: OrgTier!
  users: UserCreateNestedManyWithoutOrgsInput
  children: OrgCreateNestedManyWithoutParentInput
  surveys: SurveyCreateNestedManyWithoutOrgsInput
}

input OrgCreateOrConnectWithoutParentInput {
  where: OrgWhereUniqueInput!
  create: OrgCreateWithoutParentInput!
}

input OrgCreateManyParentInputEnvelope {
  data: [OrgCreateManyParentInput!]!
  skipDuplicates: Boolean
}

input OrgCreateManyParentInput {
  id: String
  name: String!
  orgTier: OrgTier!
}

input OrgCreateOrConnectWithoutSurveysInput {
  where: OrgWhereUniqueInput!
  create: OrgCreateWithoutSurveysInput!
}

input SurveyUpdateInput {
  id: StringFieldUpdateOperationsInput
  orgs: OrgUpdateManyWithoutSurveysInput
  questions: QuestionUpdateManyWithoutSurveysInput
  questionsHash: NullableStringFieldUpdateOperationsInput
  surveyResponses: SurveyResponseUpdateManyWithoutSurveyInput
}

input StringFieldUpdateOperationsInput {
  set: String
}

input OrgUpdateManyWithoutSurveysInput {
  create: [OrgCreateWithoutSurveysInput!]
  connectOrCreate: [OrgCreateOrConnectWithoutSurveysInput!]
  upsert: [OrgUpsertWithWhereUniqueWithoutSurveysInput!]
  set: [OrgWhereUniqueInput!]
  disconnect: [OrgWhereUniqueInput!]
  delete: [OrgWhereUniqueInput!]
  connect: [OrgWhereUniqueInput!]
  update: [OrgUpdateWithWhereUniqueWithoutSurveysInput!]
  updateMany: [OrgUpdateManyWithWhereWithoutSurveysInput!]
  deleteMany: [OrgScalarWhereInput!]
}

input OrgUpsertWithWhereUniqueWithoutSurveysInput {
  where: OrgWhereUniqueInput!
  update: OrgUpdateWithoutSurveysInput!
  create: OrgCreateWithoutSurveysInput!
}

input OrgUpdateWithoutSurveysInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  orgTier: EnumOrgTierFieldUpdateOperationsInput
  users: UserUpdateManyWithoutOrgsInput
  parent: OrgUpdateOneWithoutChildrenInput
  children: OrgUpdateManyWithoutParentInput
}

input EnumOrgTierFieldUpdateOperationsInput {
  set: OrgTier
}

input UserUpdateManyWithoutOrgsInput {
  create: [UserCreateWithoutOrgsInput!]
  connectOrCreate: [UserCreateOrConnectWithoutOrgsInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutOrgsInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutOrgsInput!]
  updateMany: [UserUpdateManyWithWhereWithoutOrgsInput!]
  deleteMany: [UserScalarWhereInput!]
}

input UserUpsertWithWhereUniqueWithoutOrgsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutOrgsInput!
  create: UserCreateWithoutOrgsInput!
}

input UserUpdateWithoutOrgsInput {
  id: StringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  enabled: BoolFieldUpdateOperationsInput
  grade: NullableStringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  refreshToken: RefreshTokenUpdateOneWithoutUserInput
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

input EnumRoleFieldUpdateOperationsInput {
  set: Role
}

input RefreshTokenUpdateOneWithoutUserInput {
  create: RefreshTokenCreateWithoutUserInput
  connectOrCreate: RefreshTokenCreateOrConnectWithoutUserInput
  upsert: RefreshTokenUpsertWithoutUserInput
  disconnect: Boolean
  delete: Boolean
  connect: RefreshTokenWhereUniqueInput
  update: RefreshTokenUpdateWithoutUserInput
}

input RefreshTokenUpsertWithoutUserInput {
  update: RefreshTokenUpdateWithoutUserInput!
  create: RefreshTokenCreateWithoutUserInput!
}

input RefreshTokenUpdateWithoutUserInput {
  id: StringFieldUpdateOperationsInput
  isRevoked: BoolFieldUpdateOperationsInput
  issuedDate: DateTimeFieldUpdateOperationsInput
  expiredDate: DateTimeFieldUpdateOperationsInput
  hash: StringFieldUpdateOperationsInput
}

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input UserUpdateWithWhereUniqueWithoutOrgsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutOrgsInput!
}

input UserUpdateManyWithWhereWithoutOrgsInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyMutationInput!
}

input UserScalarWhereInput {
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
  id: StringFilter
  email: StringFilter
  password: StringFilter
  enabled: BoolFilter
  grade: StringNullableFilter
  firstName: StringFilter
  lastName: StringFilter
  role: EnumRoleFilter
}

input UserUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  enabled: BoolFieldUpdateOperationsInput
  grade: NullableStringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
}

input OrgUpdateOneWithoutChildrenInput {
  create: OrgCreateWithoutChildrenInput
  connectOrCreate: OrgCreateOrConnectWithoutChildrenInput
  upsert: OrgUpsertWithoutChildrenInput
  disconnect: Boolean
  delete: Boolean
  connect: OrgWhereUniqueInput
  update: OrgUpdateWithoutChildrenInput
}

input OrgUpsertWithoutChildrenInput {
  update: OrgUpdateWithoutChildrenInput!
  create: OrgCreateWithoutChildrenInput!
}

input OrgUpdateWithoutChildrenInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  orgTier: EnumOrgTierFieldUpdateOperationsInput
  users: UserUpdateManyWithoutOrgsInput
  parent: OrgUpdateOneWithoutChildrenInput
  surveys: SurveyUpdateManyWithoutOrgsInput
}

input SurveyUpdateManyWithoutOrgsInput {
  create: [SurveyCreateWithoutOrgsInput!]
  connectOrCreate: [SurveyCreateOrConnectWithoutOrgsInput!]
  upsert: [SurveyUpsertWithWhereUniqueWithoutOrgsInput!]
  set: [SurveyWhereUniqueInput!]
  disconnect: [SurveyWhereUniqueInput!]
  delete: [SurveyWhereUniqueInput!]
  connect: [SurveyWhereUniqueInput!]
  update: [SurveyUpdateWithWhereUniqueWithoutOrgsInput!]
  updateMany: [SurveyUpdateManyWithWhereWithoutOrgsInput!]
  deleteMany: [SurveyScalarWhereInput!]
}

input SurveyUpsertWithWhereUniqueWithoutOrgsInput {
  where: SurveyWhereUniqueInput!
  update: SurveyUpdateWithoutOrgsInput!
  create: SurveyCreateWithoutOrgsInput!
}

input SurveyUpdateWithoutOrgsInput {
  id: StringFieldUpdateOperationsInput
  questions: QuestionUpdateManyWithoutSurveysInput
  questionsHash: NullableStringFieldUpdateOperationsInput
  surveyResponses: SurveyResponseUpdateManyWithoutSurveyInput
}

input QuestionUpdateManyWithoutSurveysInput {
  create: [QuestionCreateWithoutSurveysInput!]
  connectOrCreate: [QuestionCreateOrConnectWithoutSurveysInput!]
  upsert: [QuestionUpsertWithWhereUniqueWithoutSurveysInput!]
  set: [QuestionWhereUniqueInput!]
  disconnect: [QuestionWhereUniqueInput!]
  delete: [QuestionWhereUniqueInput!]
  connect: [QuestionWhereUniqueInput!]
  update: [QuestionUpdateWithWhereUniqueWithoutSurveysInput!]
  updateMany: [QuestionUpdateManyWithWhereWithoutSurveysInput!]
  deleteMany: [QuestionScalarWhereInput!]
}

input QuestionUpsertWithWhereUniqueWithoutSurveysInput {
  where: QuestionWhereUniqueInput!
  update: QuestionUpdateWithoutSurveysInput!
  create: QuestionCreateWithoutSurveysInput!
}

input QuestionUpdateWithoutSurveysInput {
  id: StringFieldUpdateOperationsInput
  prompt: StringFieldUpdateOperationsInput
  answers: AnswerUpdateManyWithoutQuestionInput
}

input AnswerUpdateManyWithoutQuestionInput {
  create: [AnswerCreateWithoutQuestionInput!]
  connectOrCreate: [AnswerCreateOrConnectWithoutQuestionInput!]
  upsert: [AnswerUpsertWithWhereUniqueWithoutQuestionInput!]
  createMany: AnswerCreateManyQuestionInputEnvelope
  set: [AnswerWhereUniqueInput!]
  disconnect: [AnswerWhereUniqueInput!]
  delete: [AnswerWhereUniqueInput!]
  connect: [AnswerWhereUniqueInput!]
  update: [AnswerUpdateWithWhereUniqueWithoutQuestionInput!]
  updateMany: [AnswerUpdateManyWithWhereWithoutQuestionInput!]
  deleteMany: [AnswerScalarWhereInput!]
}

input AnswerUpsertWithWhereUniqueWithoutQuestionInput {
  where: AnswerWhereUniqueInput!
  update: AnswerUpdateWithoutQuestionInput!
  create: AnswerCreateWithoutQuestionInput!
}

input AnswerUpdateWithoutQuestionInput {
  id: StringFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
  surveyResponse: SurveyResponseUpdateOneRequiredWithoutAnswersInput
}

input SurveyResponseUpdateOneRequiredWithoutAnswersInput {
  create: SurveyResponseCreateWithoutAnswersInput
  connectOrCreate: SurveyResponseCreateOrConnectWithoutAnswersInput
  upsert: SurveyResponseUpsertWithoutAnswersInput
  connect: SurveyResponseWhereUniqueInput
  update: SurveyResponseUpdateWithoutAnswersInput
}

input SurveyResponseUpsertWithoutAnswersInput {
  update: SurveyResponseUpdateWithoutAnswersInput!
  create: SurveyResponseCreateWithoutAnswersInput!
}

input SurveyResponseUpdateWithoutAnswersInput {
  id: StringFieldUpdateOperationsInput
  survey: SurveyUpdateOneRequiredWithoutSurveyResponsesInput
  openedDate: DateTimeFieldUpdateOperationsInput
  closedDate: NullableDateTimeFieldUpdateOperationsInput
  routeOutside: BoolFieldUpdateOperationsInput
  resolution: NullableStringFieldUpdateOperationsInput
}

input SurveyUpdateOneRequiredWithoutSurveyResponsesInput {
  create: SurveyCreateWithoutSurveyResponsesInput
  connectOrCreate: SurveyCreateOrConnectWithoutSurveyResponsesInput
  upsert: SurveyUpsertWithoutSurveyResponsesInput
  connect: SurveyWhereUniqueInput
  update: SurveyUpdateWithoutSurveyResponsesInput
}

input SurveyUpsertWithoutSurveyResponsesInput {
  update: SurveyUpdateWithoutSurveyResponsesInput!
  create: SurveyCreateWithoutSurveyResponsesInput!
}

input SurveyUpdateWithoutSurveyResponsesInput {
  id: StringFieldUpdateOperationsInput
  orgs: OrgUpdateManyWithoutSurveysInput
  questions: QuestionUpdateManyWithoutSurveysInput
  questionsHash: NullableStringFieldUpdateOperationsInput
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input AnswerUpdateWithWhereUniqueWithoutQuestionInput {
  where: AnswerWhereUniqueInput!
  data: AnswerUpdateWithoutQuestionInput!
}

input AnswerUpdateManyWithWhereWithoutQuestionInput {
  where: AnswerScalarWhereInput!
  data: AnswerUpdateManyMutationInput!
}

input AnswerScalarWhereInput {
  AND: [AnswerScalarWhereInput!]
  OR: [AnswerScalarWhereInput!]
  NOT: [AnswerScalarWhereInput!]
  id: StringFilter
  value: StringFilter
  questionId: StringFilter
  surveyResponseId: StringFilter
}

input AnswerUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
}

input QuestionUpdateWithWhereUniqueWithoutSurveysInput {
  where: QuestionWhereUniqueInput!
  data: QuestionUpdateWithoutSurveysInput!
}

input QuestionUpdateManyWithWhereWithoutSurveysInput {
  where: QuestionScalarWhereInput!
  data: QuestionUpdateManyMutationInput!
}

input QuestionScalarWhereInput {
  AND: [QuestionScalarWhereInput!]
  OR: [QuestionScalarWhereInput!]
  NOT: [QuestionScalarWhereInput!]
  id: StringFilter
  prompt: StringFilter
}

input QuestionUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  prompt: StringFieldUpdateOperationsInput
}

input SurveyResponseUpdateManyWithoutSurveyInput {
  create: [SurveyResponseCreateWithoutSurveyInput!]
  connectOrCreate: [SurveyResponseCreateOrConnectWithoutSurveyInput!]
  upsert: [SurveyResponseUpsertWithWhereUniqueWithoutSurveyInput!]
  createMany: SurveyResponseCreateManySurveyInputEnvelope
  set: [SurveyResponseWhereUniqueInput!]
  disconnect: [SurveyResponseWhereUniqueInput!]
  delete: [SurveyResponseWhereUniqueInput!]
  connect: [SurveyResponseWhereUniqueInput!]
  update: [SurveyResponseUpdateWithWhereUniqueWithoutSurveyInput!]
  updateMany: [SurveyResponseUpdateManyWithWhereWithoutSurveyInput!]
  deleteMany: [SurveyResponseScalarWhereInput!]
}

input SurveyResponseUpsertWithWhereUniqueWithoutSurveyInput {
  where: SurveyResponseWhereUniqueInput!
  update: SurveyResponseUpdateWithoutSurveyInput!
  create: SurveyResponseCreateWithoutSurveyInput!
}

input SurveyResponseUpdateWithoutSurveyInput {
  id: StringFieldUpdateOperationsInput
  openedDate: DateTimeFieldUpdateOperationsInput
  closedDate: NullableDateTimeFieldUpdateOperationsInput
  answers: AnswerUpdateManyWithoutSurveyResponseInput
  routeOutside: BoolFieldUpdateOperationsInput
  resolution: NullableStringFieldUpdateOperationsInput
}

input AnswerUpdateManyWithoutSurveyResponseInput {
  create: [AnswerCreateWithoutSurveyResponseInput!]
  connectOrCreate: [AnswerCreateOrConnectWithoutSurveyResponseInput!]
  upsert: [AnswerUpsertWithWhereUniqueWithoutSurveyResponseInput!]
  createMany: AnswerCreateManySurveyResponseInputEnvelope
  set: [AnswerWhereUniqueInput!]
  disconnect: [AnswerWhereUniqueInput!]
  delete: [AnswerWhereUniqueInput!]
  connect: [AnswerWhereUniqueInput!]
  update: [AnswerUpdateWithWhereUniqueWithoutSurveyResponseInput!]
  updateMany: [AnswerUpdateManyWithWhereWithoutSurveyResponseInput!]
  deleteMany: [AnswerScalarWhereInput!]
}

input AnswerUpsertWithWhereUniqueWithoutSurveyResponseInput {
  where: AnswerWhereUniqueInput!
  update: AnswerUpdateWithoutSurveyResponseInput!
  create: AnswerCreateWithoutSurveyResponseInput!
}

input AnswerUpdateWithoutSurveyResponseInput {
  id: StringFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
  question: QuestionUpdateOneRequiredWithoutAnswersInput
}

input QuestionUpdateOneRequiredWithoutAnswersInput {
  create: QuestionCreateWithoutAnswersInput
  connectOrCreate: QuestionCreateOrConnectWithoutAnswersInput
  upsert: QuestionUpsertWithoutAnswersInput
  connect: QuestionWhereUniqueInput
  update: QuestionUpdateWithoutAnswersInput
}

input QuestionUpsertWithoutAnswersInput {
  update: QuestionUpdateWithoutAnswersInput!
  create: QuestionCreateWithoutAnswersInput!
}

input QuestionUpdateWithoutAnswersInput {
  id: StringFieldUpdateOperationsInput
  prompt: StringFieldUpdateOperationsInput
  surveys: SurveyUpdateManyWithoutQuestionsInput
}

input SurveyUpdateManyWithoutQuestionsInput {
  create: [SurveyCreateWithoutQuestionsInput!]
  connectOrCreate: [SurveyCreateOrConnectWithoutQuestionsInput!]
  upsert: [SurveyUpsertWithWhereUniqueWithoutQuestionsInput!]
  set: [SurveyWhereUniqueInput!]
  disconnect: [SurveyWhereUniqueInput!]
  delete: [SurveyWhereUniqueInput!]
  connect: [SurveyWhereUniqueInput!]
  update: [SurveyUpdateWithWhereUniqueWithoutQuestionsInput!]
  updateMany: [SurveyUpdateManyWithWhereWithoutQuestionsInput!]
  deleteMany: [SurveyScalarWhereInput!]
}

input SurveyUpsertWithWhereUniqueWithoutQuestionsInput {
  where: SurveyWhereUniqueInput!
  update: SurveyUpdateWithoutQuestionsInput!
  create: SurveyCreateWithoutQuestionsInput!
}

input SurveyUpdateWithoutQuestionsInput {
  id: StringFieldUpdateOperationsInput
  orgs: OrgUpdateManyWithoutSurveysInput
  questionsHash: NullableStringFieldUpdateOperationsInput
  surveyResponses: SurveyResponseUpdateManyWithoutSurveyInput
}

input SurveyUpdateWithWhereUniqueWithoutQuestionsInput {
  where: SurveyWhereUniqueInput!
  data: SurveyUpdateWithoutQuestionsInput!
}

input SurveyUpdateManyWithWhereWithoutQuestionsInput {
  where: SurveyScalarWhereInput!
  data: SurveyUpdateManyMutationInput!
}

input SurveyScalarWhereInput {
  AND: [SurveyScalarWhereInput!]
  OR: [SurveyScalarWhereInput!]
  NOT: [SurveyScalarWhereInput!]
  id: StringFilter
  questionsHash: StringNullableFilter
}

input SurveyUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  questionsHash: NullableStringFieldUpdateOperationsInput
}

input AnswerUpdateWithWhereUniqueWithoutSurveyResponseInput {
  where: AnswerWhereUniqueInput!
  data: AnswerUpdateWithoutSurveyResponseInput!
}

input AnswerUpdateManyWithWhereWithoutSurveyResponseInput {
  where: AnswerScalarWhereInput!
  data: AnswerUpdateManyMutationInput!
}

input SurveyResponseUpdateWithWhereUniqueWithoutSurveyInput {
  where: SurveyResponseWhereUniqueInput!
  data: SurveyResponseUpdateWithoutSurveyInput!
}

input SurveyResponseUpdateManyWithWhereWithoutSurveyInput {
  where: SurveyResponseScalarWhereInput!
  data: SurveyResponseUpdateManyMutationInput!
}

input SurveyResponseScalarWhereInput {
  AND: [SurveyResponseScalarWhereInput!]
  OR: [SurveyResponseScalarWhereInput!]
  NOT: [SurveyResponseScalarWhereInput!]
  id: StringFilter
  surveyId: StringFilter
  openedDate: DateTimeFilter
  closedDate: DateTimeNullableFilter
  routeOutside: BoolFilter
  resolution: StringNullableFilter
}

input SurveyResponseUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  openedDate: DateTimeFieldUpdateOperationsInput
  closedDate: NullableDateTimeFieldUpdateOperationsInput
  routeOutside: BoolFieldUpdateOperationsInput
  resolution: NullableStringFieldUpdateOperationsInput
}

input SurveyUpdateWithWhereUniqueWithoutOrgsInput {
  where: SurveyWhereUniqueInput!
  data: SurveyUpdateWithoutOrgsInput!
}

input SurveyUpdateManyWithWhereWithoutOrgsInput {
  where: SurveyScalarWhereInput!
  data: SurveyUpdateManyMutationInput!
}

input OrgUpdateManyWithoutParentInput {
  create: [OrgCreateWithoutParentInput!]
  connectOrCreate: [OrgCreateOrConnectWithoutParentInput!]
  upsert: [OrgUpsertWithWhereUniqueWithoutParentInput!]
  createMany: OrgCreateManyParentInputEnvelope
  set: [OrgWhereUniqueInput!]
  disconnect: [OrgWhereUniqueInput!]
  delete: [OrgWhereUniqueInput!]
  connect: [OrgWhereUniqueInput!]
  update: [OrgUpdateWithWhereUniqueWithoutParentInput!]
  updateMany: [OrgUpdateManyWithWhereWithoutParentInput!]
  deleteMany: [OrgScalarWhereInput!]
}

input OrgUpsertWithWhereUniqueWithoutParentInput {
  where: OrgWhereUniqueInput!
  update: OrgUpdateWithoutParentInput!
  create: OrgCreateWithoutParentInput!
}

input OrgUpdateWithoutParentInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  orgTier: EnumOrgTierFieldUpdateOperationsInput
  users: UserUpdateManyWithoutOrgsInput
  children: OrgUpdateManyWithoutParentInput
  surveys: SurveyUpdateManyWithoutOrgsInput
}

input OrgUpdateWithWhereUniqueWithoutParentInput {
  where: OrgWhereUniqueInput!
  data: OrgUpdateWithoutParentInput!
}

input OrgUpdateManyWithWhereWithoutParentInput {
  where: OrgScalarWhereInput!
  data: OrgUpdateManyMutationInput!
}

input OrgScalarWhereInput {
  AND: [OrgScalarWhereInput!]
  OR: [OrgScalarWhereInput!]
  NOT: [OrgScalarWhereInput!]
  id: StringFilter
  name: StringFilter
  orgTier: EnumOrgTierFilter
  parentId: StringNullableFilter
}

input OrgUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  orgTier: EnumOrgTierFieldUpdateOperationsInput
}

input OrgUpdateWithWhereUniqueWithoutSurveysInput {
  where: OrgWhereUniqueInput!
  data: OrgUpdateWithoutSurveysInput!
}

input OrgUpdateManyWithWhereWithoutSurveysInput {
  where: OrgScalarWhereInput!
  data: OrgUpdateManyMutationInput!
}

input SurveyResponseCreateInput {
  id: String
  survey: SurveyCreateNestedOneWithoutSurveyResponsesInput!
  openedDate: DateTime
  closedDate: DateTime
  answers: AnswerCreateNestedManyWithoutSurveyResponseInput
  routeOutside: Boolean
  resolution: String
}

input SurveyResponseUpdateInput {
  id: StringFieldUpdateOperationsInput
  survey: SurveyUpdateOneRequiredWithoutSurveyResponsesInput
  openedDate: DateTimeFieldUpdateOperationsInput
  closedDate: NullableDateTimeFieldUpdateOperationsInput
  answers: AnswerUpdateManyWithoutSurveyResponseInput
  routeOutside: BoolFieldUpdateOperationsInput
  resolution: NullableStringFieldUpdateOperationsInput
}

input AnswerCreateInput {
  id: String
  value: String!
  question: QuestionCreateNestedOneWithoutAnswersInput!
  surveyResponse: SurveyResponseCreateNestedOneWithoutAnswersInput!
}

input OrgCreateInput {
  id: String
  name: String!
  orgTier: OrgTier!
  users: UserCreateNestedManyWithoutOrgsInput
  parent: OrgCreateNestedOneWithoutChildrenInput
  children: OrgCreateNestedManyWithoutParentInput
  surveys: SurveyCreateNestedManyWithoutOrgsInput
}

input OrgUpdateInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  orgTier: EnumOrgTierFieldUpdateOperationsInput
  users: UserUpdateManyWithoutOrgsInput
  parent: OrgUpdateOneWithoutChildrenInput
  children: OrgUpdateManyWithoutParentInput
  surveys: SurveyUpdateManyWithoutOrgsInput
}

input QuestionCreateInput {
  id: String
  prompt: String!
  surveys: SurveyCreateNestedManyWithoutQuestionsInput
  answers: AnswerCreateNestedManyWithoutQuestionInput
}

input QuestionUpdateInput {
  id: StringFieldUpdateOperationsInput
  prompt: StringFieldUpdateOperationsInput
  surveys: SurveyUpdateManyWithoutQuestionsInput
  answers: AnswerUpdateManyWithoutQuestionInput
}

input UserCreateInput {
  id: String
  email: String!
  password: String!
  enabled: Boolean
  grade: String
  firstName: String!
  lastName: String!
  role: Role!
  refreshToken: RefreshTokenCreateNestedOneWithoutUserInput
  orgs: OrgCreateNestedManyWithoutUsersInput
}

input OrgCreateNestedManyWithoutUsersInput {
  create: [OrgCreateWithoutUsersInput!]
  connectOrCreate: [OrgCreateOrConnectWithoutUsersInput!]
  connect: [OrgWhereUniqueInput!]
}

input OrgCreateWithoutUsersInput {
  id: String
  name: String!
  orgTier: OrgTier!
  parent: OrgCreateNestedOneWithoutChildrenInput
  children: OrgCreateNestedManyWithoutParentInput
  surveys: SurveyCreateNestedManyWithoutOrgsInput
}

input OrgCreateOrConnectWithoutUsersInput {
  where: OrgWhereUniqueInput!
  create: OrgCreateWithoutUsersInput!
}

input LoginUserInput {
  username: String!
  password: String!
}

input RefreshLoginInput {
  refreshToken: String!
}