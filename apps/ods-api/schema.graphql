# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type AccountRequestCountAggregate {
  id: Int!
  userId: Int!
  _all: Int!
}

type AccountRequestCount {
  comments: Int!
}

type AccountRequestMinAggregate {
  id: String
  userId: String
}

type AccountRequestMaxAggregate {
  id: String
  userId: String
}

type RefreshToken {
  id: ID!
  user: User!
  userId: String!
  isRevoked: Boolean!
  issuedDate: DateTime!
  expiredDate: DateTime!
  hash: String!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type TagCount {
  feedbackResponses: Int!
}

type Tag {
  id: ID!
  value: String!
  type: TagType!
  feedbackResponses: [FeedbackResponse!]
  _count: TagCount!
}

enum TagType {
  Resolution
  Action
}

type Comment {
  id: ID!
  value: String!
  date: DateTime!
  author: User!
  authorId: String!
  feedbackResponse: FeedbackResponse
  feedbackResponseId: String
  accountRequest: AccountRequest
  accountRequestId: String
}

type FeedbackResponseCount {
  answers: Int!
  tags: Int!
  comments: Int!
}

type FeedbackResponse {
  id: ID!
  feedback: Feedback!
  feedbackId: String!
  openedDate: DateTime!
  closedDate: DateTime
  answers: [Answer!]
  routeOutside: Boolean!
  tags: [Tag!]
  comments: [Comment!]
  resolved: Boolean!
  reviewedBy: User
  reviewerId: String
  resolvedComment: String
  _count: FeedbackResponseCount!
}

type Answer {
  id: ID!
  value: String!
  question: Question!
  questionId: String!
  feedbackResponse: FeedbackResponse!
  feedbackResponseId: String!
}

type QuestionCount {
  feedbacks: Int!
  answers: Int!
}

type Question {
  id: ID!
  value: String!
  feedbacks: [Feedback!]
  answers: [Answer!]
  _count: QuestionCount!
}

type FeedbackCount {
  orgs: Int!
  questions: Int!
  feedbackResponses: Int!
}

type Feedback {
  id: ID!
  orgs: [Org!]
  questions: [Question!]
  questionsHash: String
  feedbackResponses: [FeedbackResponse!]
  _count: FeedbackCount!
}

type OrgCount {
  users: Int!
  children: Int!
  feedbacks: Int!
}

type Org {
  id: ID!
  name: String!
  orgTier: OrgTier!
  users: [User!]
  parentId: String
  parent: Org
  children: [Org!]
  feedbacks: [Feedback!]
  _count: OrgCount!
}

enum OrgTier {
  WING
  GROUP
  SQUADRON
  OTHER
}

type UserCount {
  orgs: Int!
  comments: Int!
  reviewedResponses: Int!
}

type User {
  id: ID!
  email: String!
  grade: String
  firstName: String!
  lastName: String!
  status: Status!
  role: Role!
  refreshToken: RefreshToken
  orgs: [Org!]
  comments: [Comment!]
  reviewedResponses: [FeedbackResponse!]
  accountRequest: AccountRequest
  _count: UserCount!
}

enum Status {
  DISABLED
  ENABLED
  REQUESTED
  DENIED
}

enum Role {
  ADMIN
  DEI
  CC
}

type AccountRequest {
  id: ID!
  user: User!
  userId: String!
  comments: [Comment!]
  _count: AccountRequestCount!
}

type AnswerCountAggregate {
  id: Int!
  value: Int!
  questionId: Int!
  feedbackResponseId: Int!
  _all: Int!
}

type AnswerMinAggregate {
  id: String
  value: String
  questionId: String
  feedbackResponseId: String
}

type AnswerMaxAggregate {
  id: String
  value: String
  questionId: String
  feedbackResponseId: String
}

type CommentCountAggregate {
  id: Int!
  value: Int!
  date: Int!
  authorId: Int!
  feedbackResponseId: Int!
  accountRequestId: Int!
  _all: Int!
}

type CommentMinAggregate {
  id: String
  value: String
  date: DateTime
  authorId: String
  feedbackResponseId: String
  accountRequestId: String
}

type CommentMaxAggregate {
  id: String
  value: String
  date: DateTime
  authorId: String
  feedbackResponseId: String
  accountRequestId: String
}

type FeedbackCountAggregate {
  id: Int!
  questionsHash: Int!
  _all: Int!
}

type FeedbackMinAggregate {
  id: String
  questionsHash: String
}

type FeedbackMaxAggregate {
  id: String
  questionsHash: String
}

type FeedbackResponseCountAggregate {
  id: Int!
  feedbackId: Int!
  openedDate: Int!
  closedDate: Int!
  routeOutside: Int!
  resolved: Int!
  reviewerId: Int!
  resolvedComment: Int!
  _all: Int!
}

type FeedbackResponseMinAggregate {
  id: String
  feedbackId: String
  openedDate: DateTime
  closedDate: DateTime
  routeOutside: Boolean
  resolved: Boolean
  reviewerId: String
  resolvedComment: String
}

type FeedbackResponseMaxAggregate {
  id: String
  feedbackId: String
  openedDate: DateTime
  closedDate: DateTime
  routeOutside: Boolean
  resolved: Boolean
  reviewerId: String
  resolvedComment: String
}

type OrgCountAggregate {
  id: Int!
  name: Int!
  orgTier: Int!
  parentId: Int!
  _all: Int!
}

type OrgMinAggregate {
  id: String
  name: String
  orgTier: OrgTier
  parentId: String
}

type OrgMaxAggregate {
  id: String
  name: String
  orgTier: OrgTier
  parentId: String
}

type QuestionCountAggregate {
  id: Int!
  value: Int!
  _all: Int!
}

type QuestionMinAggregate {
  id: String
  value: String
}

type QuestionMaxAggregate {
  id: String
  value: String
}

type RefreshTokenCountAggregate {
  id: Int!
  userId: Int!
  isRevoked: Int!
  issuedDate: Int!
  expiredDate: Int!
  hash: Int!
  _all: Int!
}

type RefreshTokenMinAggregate {
  id: String
  userId: String
  isRevoked: Boolean
  issuedDate: DateTime
  expiredDate: DateTime
  hash: String
}

type RefreshTokenMaxAggregate {
  id: String
  userId: String
  isRevoked: Boolean
  issuedDate: DateTime
  expiredDate: DateTime
  hash: String
}

type TagCountAggregate {
  id: Int!
  value: Int!
  type: Int!
  _all: Int!
}

type TagMinAggregate {
  id: String
  value: String
  type: TagType
}

type TagMaxAggregate {
  id: String
  value: String
  type: TagType
}

type UserCountAggregate {
  id: Int!
  email: Int!
  grade: Int!
  firstName: Int!
  lastName: Int!
  status: Int!
  role: Int!
  _all: Int!
}

type UserMinAggregate {
  id: String
  email: String
  grade: String
  firstName: String
  lastName: String
  status: Status
  role: Role
}

type UserMaxAggregate {
  id: String
  email: String
  grade: String
  firstName: String
  lastName: String
  status: Status
  role: Role
}

type Tokens {
  accessToken: String!
  refreshToken: String!
}

type ResponseCount {
  unresolved: Float!
  overdue: Float!
  resolved: Float!
}

type TrackedFeedback {
  openedDate: DateTime!
  closedDate: DateTime
  resolved: Boolean!
  tags: [String!]!
  grade: String
  firstName: String
  lastName: String
  resolvedComment: String
}

type Query {
  findUniqueFeedback(feedbackWhereUniqueInput: FeedbackWhereUniqueInput!): Feedback!
  findUniqueAccountRequest(accountRequestWhereUniqueInput: AccountRequestWhereUniqueInput!): AccountRequest!
  findUniqueFeedbackResponse(feedbackResponseWhereUniqueInput: FeedbackResponseWhereUniqueInput!): FeedbackResponse!
  feedbackResponseByID(feedbackResponseWhereUniqueInput: FeedbackResponseWhereUniqueInput!): TrackedFeedback!
  getResponseCount(where: FeedbackResponseWhereInput, orderBy: [FeedbackResponseOrderByWithRelationInput!], cursor: FeedbackResponseWhereUniqueInput, take: Int, skip: Int, _count: FeedbackResponseCountAggregateInput, _min: FeedbackResponseMinAggregateInput, _max: FeedbackResponseMaxAggregateInput): Int!
  ResponseCount: ResponseCount!
  getIssuesByStatus(status: String!, where: FeedbackResponseWhereInput, orderBy: [FeedbackResponseOrderByWithRelationInput!], cursor: FeedbackResponseWhereUniqueInput, take: Int, skip: Int, distinct: [FeedbackResponseScalarFieldEnum!]): [FeedbackResponse!]!
  getUserOrgsNames: [String!]!
  getOrgLineage: [String!]!
  getOrgNames: [String!]!
  getOrgChildren(orgName: String!): [String!]!
  checkOrg(orgName: String!): Boolean!
  getOrgTier(orgName: String!): OrgTier!
  getOrgsBelowTier(orgTier: OrgTier!): [String!]!
  getOrgsBelowTierWithKeepParents(orgTier: OrgTier!): [String!]!
  getOrgsAboveTier(orgTier: OrgTier!): [String!]!
  getTiersByUser: [String!]!
  getSubQuestions(feedbackWhereUniqueInput: FeedbackWhereUniqueInput!): [String!]!
  findManyUsers(where: UserWhereInput, orderBy: [UserOrderByWithRelationInput!], cursor: UserWhereUniqueInput, take: Int, skip: Int, distinct: [UserScalarFieldEnum!]): [User!]!
  getCommanders: [String!]!
  me: User!
  findManyAccountRequests: [User!]!
  getTags: [Tag!]!
  usernameOrEmailExists(usernameOrEmail: String!): Boolean!
}

input FeedbackWhereUniqueInput {
  id: String
  questionsHash: String
}

input AccountRequestWhereUniqueInput {
  id: String
  userId: String
}

input FeedbackResponseWhereUniqueInput {
  id: String
}

input FeedbackResponseWhereInput {
  AND: [FeedbackResponseWhereInput!]
  OR: [FeedbackResponseWhereInput!]
  NOT: [FeedbackResponseWhereInput!]
  id: StringFilter
  feedback: FeedbackRelationFilter
  feedbackId: StringFilter
  openedDate: DateTimeFilter
  closedDate: DateTimeNullableFilter
  answers: AnswerListRelationFilter
  routeOutside: BoolFilter
  tags: TagListRelationFilter
  comments: CommentListRelationFilter
  resolved: BoolFilter
  reviewedBy: UserRelationFilter
  reviewerId: StringNullableFilter
  resolvedComment: StringNullableFilter
}

input StringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringFilter
}

enum QueryMode {
  default
  insensitive
}

input NestedStringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringFilter
}

input FeedbackRelationFilter {
  is: FeedbackWhereInput
  isNot: FeedbackWhereInput
}

input FeedbackWhereInput {
  AND: [FeedbackWhereInput!]
  OR: [FeedbackWhereInput!]
  NOT: [FeedbackWhereInput!]
  id: StringFilter
  orgs: OrgListRelationFilter
  questions: QuestionListRelationFilter
  questionsHash: StringNullableFilter
  feedbackResponses: FeedbackResponseListRelationFilter
}

input OrgListRelationFilter {
  every: OrgWhereInput
  some: OrgWhereInput
  none: OrgWhereInput
}

input OrgWhereInput {
  AND: [OrgWhereInput!]
  OR: [OrgWhereInput!]
  NOT: [OrgWhereInput!]
  id: StringFilter
  name: StringFilter
  orgTier: EnumOrgTierFilter
  users: UserListRelationFilter
  parentId: StringNullableFilter
  parent: OrgRelationFilter
  children: OrgListRelationFilter
  feedbacks: FeedbackListRelationFilter
}

input EnumOrgTierFilter {
  equals: OrgTier
  in: [OrgTier!]
  notIn: [OrgTier!]
  not: NestedEnumOrgTierFilter
}

input NestedEnumOrgTierFilter {
  equals: OrgTier
  in: [OrgTier!]
  notIn: [OrgTier!]
  not: NestedEnumOrgTierFilter
}

input UserListRelationFilter {
  every: UserWhereInput
  some: UserWhereInput
  none: UserWhereInput
}

input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
  id: StringFilter
  email: StringFilter
  password: StringFilter
  grade: StringNullableFilter
  firstName: StringFilter
  lastName: StringFilter
  status: EnumStatusFilter
  role: EnumRoleFilter
  refreshToken: RefreshTokenRelationFilter
  orgs: OrgListRelationFilter
  comments: CommentListRelationFilter
  reviewedResponses: FeedbackResponseListRelationFilter
  accountRequest: AccountRequestRelationFilter
}

input StringNullableFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringNullableFilter
}

input NestedStringNullableFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringNullableFilter
}

input EnumStatusFilter {
  equals: Status
  in: [Status!]
  notIn: [Status!]
  not: NestedEnumStatusFilter
}

input NestedEnumStatusFilter {
  equals: Status
  in: [Status!]
  notIn: [Status!]
  not: NestedEnumStatusFilter
}

input EnumRoleFilter {
  equals: Role
  in: [Role!]
  notIn: [Role!]
  not: NestedEnumRoleFilter
}

input NestedEnumRoleFilter {
  equals: Role
  in: [Role!]
  notIn: [Role!]
  not: NestedEnumRoleFilter
}

input RefreshTokenRelationFilter {
  is: RefreshTokenWhereInput
  isNot: RefreshTokenWhereInput
}

input RefreshTokenWhereInput {
  AND: [RefreshTokenWhereInput!]
  OR: [RefreshTokenWhereInput!]
  NOT: [RefreshTokenWhereInput!]
  id: StringFilter
  user: UserRelationFilter
  userId: StringFilter
  isRevoked: BoolFilter
  issuedDate: DateTimeFilter
  expiredDate: DateTimeFilter
  hash: StringFilter
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input DateTimeFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: NestedDateTimeFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: NestedDateTimeFilter
}

input CommentListRelationFilter {
  every: CommentWhereInput
  some: CommentWhereInput
  none: CommentWhereInput
}

input CommentWhereInput {
  AND: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  NOT: [CommentWhereInput!]
  id: StringFilter
  value: StringFilter
  date: DateTimeFilter
  author: UserRelationFilter
  authorId: StringFilter
  feedbackResponse: FeedbackResponseRelationFilter
  feedbackResponseId: StringNullableFilter
  accountRequest: AccountRequestRelationFilter
  accountRequestId: StringNullableFilter
}

input FeedbackResponseRelationFilter {
  is: FeedbackResponseWhereInput
  isNot: FeedbackResponseWhereInput
}

input AccountRequestRelationFilter {
  is: AccountRequestWhereInput
  isNot: AccountRequestWhereInput
}

input AccountRequestWhereInput {
  AND: [AccountRequestWhereInput!]
  OR: [AccountRequestWhereInput!]
  NOT: [AccountRequestWhereInput!]
  id: StringFilter
  user: UserRelationFilter
  userId: StringFilter
  comments: CommentListRelationFilter
}

input FeedbackResponseListRelationFilter {
  every: FeedbackResponseWhereInput
  some: FeedbackResponseWhereInput
  none: FeedbackResponseWhereInput
}

input OrgRelationFilter {
  is: OrgWhereInput
  isNot: OrgWhereInput
}

input FeedbackListRelationFilter {
  every: FeedbackWhereInput
  some: FeedbackWhereInput
  none: FeedbackWhereInput
}

input QuestionListRelationFilter {
  every: QuestionWhereInput
  some: QuestionWhereInput
  none: QuestionWhereInput
}

input QuestionWhereInput {
  AND: [QuestionWhereInput!]
  OR: [QuestionWhereInput!]
  NOT: [QuestionWhereInput!]
  id: StringFilter
  value: StringFilter
  feedbacks: FeedbackListRelationFilter
  answers: AnswerListRelationFilter
}

input AnswerListRelationFilter {
  every: AnswerWhereInput
  some: AnswerWhereInput
  none: AnswerWhereInput
}

input AnswerWhereInput {
  AND: [AnswerWhereInput!]
  OR: [AnswerWhereInput!]
  NOT: [AnswerWhereInput!]
  id: StringFilter
  value: StringFilter
  question: QuestionRelationFilter
  questionId: StringFilter
  feedbackResponse: FeedbackResponseRelationFilter
  feedbackResponseId: StringFilter
}

input QuestionRelationFilter {
  is: QuestionWhereInput
  isNot: QuestionWhereInput
}

input DateTimeNullableFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: NestedDateTimeNullableFilter
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: NestedDateTimeNullableFilter
}

input TagListRelationFilter {
  every: TagWhereInput
  some: TagWhereInput
  none: TagWhereInput
}

input TagWhereInput {
  AND: [TagWhereInput!]
  OR: [TagWhereInput!]
  NOT: [TagWhereInput!]
  id: StringFilter
  value: StringFilter
  type: EnumTagTypeFilter
  feedbackResponses: FeedbackResponseListRelationFilter
}

input EnumTagTypeFilter {
  equals: TagType
  in: [TagType!]
  notIn: [TagType!]
  not: NestedEnumTagTypeFilter
}

input NestedEnumTagTypeFilter {
  equals: TagType
  in: [TagType!]
  notIn: [TagType!]
  not: NestedEnumTagTypeFilter
}

input FeedbackResponseOrderByWithRelationInput {
  id: SortOrder
  feedback: FeedbackOrderByWithRelationInput
  feedbackId: SortOrder
  openedDate: SortOrder
  closedDate: SortOrder
  answers: AnswerOrderByRelationAggregateInput
  routeOutside: SortOrder
  tags: TagOrderByRelationAggregateInput
  comments: CommentOrderByRelationAggregateInput
  resolved: SortOrder
  reviewedBy: UserOrderByWithRelationInput
  reviewerId: SortOrder
  resolvedComment: SortOrder
}

enum SortOrder {
  asc
  desc
}

input FeedbackOrderByWithRelationInput {
  id: SortOrder
  orgs: OrgOrderByRelationAggregateInput
  questions: QuestionOrderByRelationAggregateInput
  questionsHash: SortOrder
  feedbackResponses: FeedbackResponseOrderByRelationAggregateInput
}

input OrgOrderByRelationAggregateInput {
  _count: SortOrder
}

input QuestionOrderByRelationAggregateInput {
  _count: SortOrder
}

input FeedbackResponseOrderByRelationAggregateInput {
  _count: SortOrder
}

input AnswerOrderByRelationAggregateInput {
  _count: SortOrder
}

input TagOrderByRelationAggregateInput {
  _count: SortOrder
}

input CommentOrderByRelationAggregateInput {
  _count: SortOrder
}

input UserOrderByWithRelationInput {
  id: SortOrder
  email: SortOrder
  password: SortOrder
  grade: SortOrder
  firstName: SortOrder
  lastName: SortOrder
  status: SortOrder
  role: SortOrder
  refreshToken: RefreshTokenOrderByWithRelationInput
  orgs: OrgOrderByRelationAggregateInput
  comments: CommentOrderByRelationAggregateInput
  reviewedResponses: FeedbackResponseOrderByRelationAggregateInput
  accountRequest: AccountRequestOrderByWithRelationInput
}

input RefreshTokenOrderByWithRelationInput {
  id: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
  isRevoked: SortOrder
  issuedDate: SortOrder
  expiredDate: SortOrder
  hash: SortOrder
}

input AccountRequestOrderByWithRelationInput {
  id: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
  comments: CommentOrderByRelationAggregateInput
}

input FeedbackResponseCountAggregateInput {
  id: Boolean
  feedbackId: Boolean
  openedDate: Boolean
  closedDate: Boolean
  routeOutside: Boolean
  resolved: Boolean
  reviewerId: Boolean
  resolvedComment: Boolean
  _all: Boolean
}

input FeedbackResponseMinAggregateInput {
  id: Boolean
  feedbackId: Boolean
  openedDate: Boolean
  closedDate: Boolean
  routeOutside: Boolean
  resolved: Boolean
  reviewerId: Boolean
  resolvedComment: Boolean
}

input FeedbackResponseMaxAggregateInput {
  id: Boolean
  feedbackId: Boolean
  openedDate: Boolean
  closedDate: Boolean
  routeOutside: Boolean
  resolved: Boolean
  reviewerId: Boolean
  resolvedComment: Boolean
}

enum FeedbackResponseScalarFieldEnum {
  id
  feedbackId
  openedDate
  closedDate
  routeOutside
  resolved
  reviewerId
  resolvedComment
}

input UserWhereUniqueInput {
  id: String
  email: String
}

enum UserScalarFieldEnum {
  id
  email
  password
  grade
  firstName
  lastName
  status
  role
}

type Mutation {
  createFeedbackWithQuestions(questionValues: [String!]!, orgWhereUniqueInput: OrgWhereUniqueInput!): String!
  updateFeedback(data: FeedbackUpdateInput!, where: FeedbackWhereUniqueInput!): Feedback!
  updateAccountRequest(data: AccountRequestUpdateInput!, where: AccountRequestWhereUniqueInput!): AccountRequest!
  createFeedbackResponse(feedbackResponseCreateInput: FeedbackResponseCreateInput!): String!
  updateFeedbackResponse(data: FeedbackResponseUpdateInput!, where: FeedbackResponseWhereUniqueInput!): FeedbackResponse!
  createOrg(orgCreateInput: OrgCreateInput!): String!
  updateOrg(data: OrgUpdateInput!, where: OrgWhereUniqueInput!): Org!
  deleteOrg(orgWhereUniqueInput: OrgWhereUniqueInput!): Org
  createUser(userCreateInput: UserCreateInput!): String!
  enableAccount(userWhereUniqueInput: UserWhereUniqueInput!): User!
  deleteUser(userWhereUniqueInput: UserWhereUniqueInput!): User
  login(loginUserInput: LoginUserInput!): Tokens!
  refreshTokens(refreshLoginInput: RefreshLoginInput!): Tokens!
}

input OrgWhereUniqueInput {
  id: String
  name: String
}

input FeedbackUpdateInput {
  id: StringFieldUpdateOperationsInput
  orgs: OrgUpdateManyWithoutFeedbacksNestedInput
  questions: QuestionUpdateManyWithoutFeedbacksNestedInput
  questionsHash: NullableStringFieldUpdateOperationsInput
  feedbackResponses: FeedbackResponseUpdateManyWithoutFeedbackNestedInput
}

input StringFieldUpdateOperationsInput {
  set: String
}

input OrgUpdateManyWithoutFeedbacksNestedInput {
  create: [OrgCreateWithoutFeedbacksInput!]
  connectOrCreate: [OrgCreateOrConnectWithoutFeedbacksInput!]
  upsert: [OrgUpsertWithWhereUniqueWithoutFeedbacksInput!]
  set: [OrgWhereUniqueInput!]
  disconnect: [OrgWhereUniqueInput!]
  delete: [OrgWhereUniqueInput!]
  connect: [OrgWhereUniqueInput!]
  update: [OrgUpdateWithWhereUniqueWithoutFeedbacksInput!]
  updateMany: [OrgUpdateManyWithWhereWithoutFeedbacksInput!]
  deleteMany: [OrgScalarWhereInput!]
}

input OrgCreateWithoutFeedbacksInput {
  id: String
  name: String!
  orgTier: OrgTier!
  users: UserCreateNestedManyWithoutOrgsInput
  parent: OrgCreateNestedOneWithoutChildrenInput
  children: OrgCreateNestedManyWithoutParentInput
}

input UserCreateNestedManyWithoutOrgsInput {
  create: [UserCreateWithoutOrgsInput!]
  connectOrCreate: [UserCreateOrConnectWithoutOrgsInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateWithoutOrgsInput {
  id: String
  email: String!
  password: String!
  grade: String
  firstName: String!
  lastName: String!
  status: Status!
  role: Role!
  refreshToken: RefreshTokenCreateNestedOneWithoutUserInput
  comments: CommentCreateNestedManyWithoutAuthorInput
  reviewedResponses: FeedbackResponseCreateNestedManyWithoutReviewedByInput
  accountRequest: AccountRequestCreateNestedOneWithoutUserInput
}

input RefreshTokenCreateNestedOneWithoutUserInput {
  create: RefreshTokenCreateWithoutUserInput
  connectOrCreate: RefreshTokenCreateOrConnectWithoutUserInput
  connect: RefreshTokenWhereUniqueInput
}

input RefreshTokenCreateWithoutUserInput {
  id: String
  isRevoked: Boolean
  issuedDate: DateTime
  expiredDate: DateTime!
  hash: String!
}

input RefreshTokenCreateOrConnectWithoutUserInput {
  where: RefreshTokenWhereUniqueInput!
  create: RefreshTokenCreateWithoutUserInput!
}

input RefreshTokenWhereUniqueInput {
  id: String
  userId: String
}

input CommentCreateNestedManyWithoutAuthorInput {
  create: [CommentCreateWithoutAuthorInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutAuthorInput!]
  createMany: CommentCreateManyAuthorInputEnvelope
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateWithoutAuthorInput {
  id: String
  value: String!
  date: DateTime
  feedbackResponse: FeedbackResponseCreateNestedOneWithoutCommentsInput
  accountRequest: AccountRequestCreateNestedOneWithoutCommentsInput
}

input FeedbackResponseCreateNestedOneWithoutCommentsInput {
  create: FeedbackResponseCreateWithoutCommentsInput
  connectOrCreate: FeedbackResponseCreateOrConnectWithoutCommentsInput
  connect: FeedbackResponseWhereUniqueInput
}

input FeedbackResponseCreateWithoutCommentsInput {
  id: String
  feedback: FeedbackCreateNestedOneWithoutFeedbackResponsesInput!
  openedDate: DateTime
  closedDate: DateTime
  answers: AnswerCreateNestedManyWithoutFeedbackResponseInput
  routeOutside: Boolean
  tags: TagCreateNestedManyWithoutFeedbackResponsesInput
  resolved: Boolean
  reviewedBy: UserCreateNestedOneWithoutReviewedResponsesInput
  resolvedComment: String
}

input FeedbackCreateNestedOneWithoutFeedbackResponsesInput {
  create: FeedbackCreateWithoutFeedbackResponsesInput
  connectOrCreate: FeedbackCreateOrConnectWithoutFeedbackResponsesInput
  connect: FeedbackWhereUniqueInput
}

input FeedbackCreateWithoutFeedbackResponsesInput {
  id: String
  orgs: OrgCreateNestedManyWithoutFeedbacksInput
  questions: QuestionCreateNestedManyWithoutFeedbacksInput
  questionsHash: String
}

input OrgCreateNestedManyWithoutFeedbacksInput {
  create: [OrgCreateWithoutFeedbacksInput!]
  connectOrCreate: [OrgCreateOrConnectWithoutFeedbacksInput!]
  connect: [OrgWhereUniqueInput!]
}

input OrgCreateOrConnectWithoutFeedbacksInput {
  where: OrgWhereUniqueInput!
  create: OrgCreateWithoutFeedbacksInput!
}

input QuestionCreateNestedManyWithoutFeedbacksInput {
  create: [QuestionCreateWithoutFeedbacksInput!]
  connectOrCreate: [QuestionCreateOrConnectWithoutFeedbacksInput!]
  connect: [QuestionWhereUniqueInput!]
}

input QuestionCreateWithoutFeedbacksInput {
  id: String
  value: String!
  answers: AnswerCreateNestedManyWithoutQuestionInput
}

input AnswerCreateNestedManyWithoutQuestionInput {
  create: [AnswerCreateWithoutQuestionInput!]
  connectOrCreate: [AnswerCreateOrConnectWithoutQuestionInput!]
  createMany: AnswerCreateManyQuestionInputEnvelope
  connect: [AnswerWhereUniqueInput!]
}

input AnswerCreateWithoutQuestionInput {
  id: String
  value: String!
  feedbackResponse: FeedbackResponseCreateNestedOneWithoutAnswersInput!
}

input FeedbackResponseCreateNestedOneWithoutAnswersInput {
  create: FeedbackResponseCreateWithoutAnswersInput
  connectOrCreate: FeedbackResponseCreateOrConnectWithoutAnswersInput
  connect: FeedbackResponseWhereUniqueInput
}

input FeedbackResponseCreateWithoutAnswersInput {
  id: String
  feedback: FeedbackCreateNestedOneWithoutFeedbackResponsesInput!
  openedDate: DateTime
  closedDate: DateTime
  routeOutside: Boolean
  tags: TagCreateNestedManyWithoutFeedbackResponsesInput
  comments: CommentCreateNestedManyWithoutFeedbackResponseInput
  resolved: Boolean
  reviewedBy: UserCreateNestedOneWithoutReviewedResponsesInput
  resolvedComment: String
}

input TagCreateNestedManyWithoutFeedbackResponsesInput {
  create: [TagCreateWithoutFeedbackResponsesInput!]
  connectOrCreate: [TagCreateOrConnectWithoutFeedbackResponsesInput!]
  connect: [TagWhereUniqueInput!]
}

input TagCreateWithoutFeedbackResponsesInput {
  id: String
  value: String!
  type: TagType!
}

input TagCreateOrConnectWithoutFeedbackResponsesInput {
  where: TagWhereUniqueInput!
  create: TagCreateWithoutFeedbackResponsesInput!
}

input TagWhereUniqueInput {
  id: String
  value: String
}

input CommentCreateNestedManyWithoutFeedbackResponseInput {
  create: [CommentCreateWithoutFeedbackResponseInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutFeedbackResponseInput!]
  createMany: CommentCreateManyFeedbackResponseInputEnvelope
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateWithoutFeedbackResponseInput {
  id: String
  value: String!
  date: DateTime
  author: UserCreateNestedOneWithoutCommentsInput!
  accountRequest: AccountRequestCreateNestedOneWithoutCommentsInput
}

input UserCreateNestedOneWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput
  connectOrCreate: UserCreateOrConnectWithoutCommentsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutCommentsInput {
  id: String
  email: String!
  password: String!
  grade: String
  firstName: String!
  lastName: String!
  status: Status!
  role: Role!
  refreshToken: RefreshTokenCreateNestedOneWithoutUserInput
  orgs: OrgCreateNestedManyWithoutUsersInput
  reviewedResponses: FeedbackResponseCreateNestedManyWithoutReviewedByInput
  accountRequest: AccountRequestCreateNestedOneWithoutUserInput
}

input OrgCreateNestedManyWithoutUsersInput {
  create: [OrgCreateWithoutUsersInput!]
  connectOrCreate: [OrgCreateOrConnectWithoutUsersInput!]
  connect: [OrgWhereUniqueInput!]
}

input OrgCreateWithoutUsersInput {
  id: String
  name: String!
  orgTier: OrgTier!
  parent: OrgCreateNestedOneWithoutChildrenInput
  children: OrgCreateNestedManyWithoutParentInput
  feedbacks: FeedbackCreateNestedManyWithoutOrgsInput
}

input OrgCreateNestedOneWithoutChildrenInput {
  create: OrgCreateWithoutChildrenInput
  connectOrCreate: OrgCreateOrConnectWithoutChildrenInput
  connect: OrgWhereUniqueInput
}

input OrgCreateWithoutChildrenInput {
  id: String
  name: String!
  orgTier: OrgTier!
  users: UserCreateNestedManyWithoutOrgsInput
  parent: OrgCreateNestedOneWithoutChildrenInput
  feedbacks: FeedbackCreateNestedManyWithoutOrgsInput
}

input FeedbackCreateNestedManyWithoutOrgsInput {
  create: [FeedbackCreateWithoutOrgsInput!]
  connectOrCreate: [FeedbackCreateOrConnectWithoutOrgsInput!]
  connect: [FeedbackWhereUniqueInput!]
}

input FeedbackCreateWithoutOrgsInput {
  id: String
  questions: QuestionCreateNestedManyWithoutFeedbacksInput
  questionsHash: String
  feedbackResponses: FeedbackResponseCreateNestedManyWithoutFeedbackInput
}

input FeedbackResponseCreateNestedManyWithoutFeedbackInput {
  create: [FeedbackResponseCreateWithoutFeedbackInput!]
  connectOrCreate: [FeedbackResponseCreateOrConnectWithoutFeedbackInput!]
  createMany: FeedbackResponseCreateManyFeedbackInputEnvelope
  connect: [FeedbackResponseWhereUniqueInput!]
}

input FeedbackResponseCreateWithoutFeedbackInput {
  id: String
  openedDate: DateTime
  closedDate: DateTime
  answers: AnswerCreateNestedManyWithoutFeedbackResponseInput
  routeOutside: Boolean
  tags: TagCreateNestedManyWithoutFeedbackResponsesInput
  comments: CommentCreateNestedManyWithoutFeedbackResponseInput
  resolved: Boolean
  reviewedBy: UserCreateNestedOneWithoutReviewedResponsesInput
  resolvedComment: String
}

input AnswerCreateNestedManyWithoutFeedbackResponseInput {
  create: [AnswerCreateWithoutFeedbackResponseInput!]
  connectOrCreate: [AnswerCreateOrConnectWithoutFeedbackResponseInput!]
  createMany: AnswerCreateManyFeedbackResponseInputEnvelope
  connect: [AnswerWhereUniqueInput!]
}

input AnswerCreateWithoutFeedbackResponseInput {
  id: String
  value: String!
  question: QuestionCreateNestedOneWithoutAnswersInput!
}

input QuestionCreateNestedOneWithoutAnswersInput {
  create: QuestionCreateWithoutAnswersInput
  connectOrCreate: QuestionCreateOrConnectWithoutAnswersInput
  connect: QuestionWhereUniqueInput
}

input QuestionCreateWithoutAnswersInput {
  id: String
  value: String!
  feedbacks: FeedbackCreateNestedManyWithoutQuestionsInput
}

input FeedbackCreateNestedManyWithoutQuestionsInput {
  create: [FeedbackCreateWithoutQuestionsInput!]
  connectOrCreate: [FeedbackCreateOrConnectWithoutQuestionsInput!]
  connect: [FeedbackWhereUniqueInput!]
}

input FeedbackCreateWithoutQuestionsInput {
  id: String
  orgs: OrgCreateNestedManyWithoutFeedbacksInput
  questionsHash: String
  feedbackResponses: FeedbackResponseCreateNestedManyWithoutFeedbackInput
}

input FeedbackCreateOrConnectWithoutQuestionsInput {
  where: FeedbackWhereUniqueInput!
  create: FeedbackCreateWithoutQuestionsInput!
}

input QuestionCreateOrConnectWithoutAnswersInput {
  where: QuestionWhereUniqueInput!
  create: QuestionCreateWithoutAnswersInput!
}

input QuestionWhereUniqueInput {
  id: String
  value: String
}

input AnswerCreateOrConnectWithoutFeedbackResponseInput {
  where: AnswerWhereUniqueInput!
  create: AnswerCreateWithoutFeedbackResponseInput!
}

input AnswerWhereUniqueInput {
  id: String
}

input AnswerCreateManyFeedbackResponseInputEnvelope {
  data: [AnswerCreateManyFeedbackResponseInput!]!
  skipDuplicates: Boolean
}

input AnswerCreateManyFeedbackResponseInput {
  id: String
  value: String!
  questionId: String!
}

input UserCreateNestedOneWithoutReviewedResponsesInput {
  create: UserCreateWithoutReviewedResponsesInput
  connectOrCreate: UserCreateOrConnectWithoutReviewedResponsesInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutReviewedResponsesInput {
  id: String
  email: String!
  password: String!
  grade: String
  firstName: String!
  lastName: String!
  status: Status!
  role: Role!
  refreshToken: RefreshTokenCreateNestedOneWithoutUserInput
  orgs: OrgCreateNestedManyWithoutUsersInput
  comments: CommentCreateNestedManyWithoutAuthorInput
  accountRequest: AccountRequestCreateNestedOneWithoutUserInput
}

input AccountRequestCreateNestedOneWithoutUserInput {
  create: AccountRequestCreateWithoutUserInput
  connectOrCreate: AccountRequestCreateOrConnectWithoutUserInput
  connect: AccountRequestWhereUniqueInput
}

input AccountRequestCreateWithoutUserInput {
  id: String
  comments: CommentCreateNestedManyWithoutAccountRequestInput
}

input CommentCreateNestedManyWithoutAccountRequestInput {
  create: [CommentCreateWithoutAccountRequestInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutAccountRequestInput!]
  createMany: CommentCreateManyAccountRequestInputEnvelope
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateWithoutAccountRequestInput {
  id: String
  value: String!
  date: DateTime
  author: UserCreateNestedOneWithoutCommentsInput!
  feedbackResponse: FeedbackResponseCreateNestedOneWithoutCommentsInput
}

input CommentCreateOrConnectWithoutAccountRequestInput {
  where: CommentWhereUniqueInput!
  create: CommentCreateWithoutAccountRequestInput!
}

input CommentWhereUniqueInput {
  id: String
}

input CommentCreateManyAccountRequestInputEnvelope {
  data: [CommentCreateManyAccountRequestInput!]!
  skipDuplicates: Boolean
}

input CommentCreateManyAccountRequestInput {
  id: String
  value: String!
  date: DateTime
  authorId: String!
  feedbackResponseId: String
}

input AccountRequestCreateOrConnectWithoutUserInput {
  where: AccountRequestWhereUniqueInput!
  create: AccountRequestCreateWithoutUserInput!
}

input UserCreateOrConnectWithoutReviewedResponsesInput {
  where: UserWhereUniqueInput!
  create: UserCreateWithoutReviewedResponsesInput!
}

input FeedbackResponseCreateOrConnectWithoutFeedbackInput {
  where: FeedbackResponseWhereUniqueInput!
  create: FeedbackResponseCreateWithoutFeedbackInput!
}

input FeedbackResponseCreateManyFeedbackInputEnvelope {
  data: [FeedbackResponseCreateManyFeedbackInput!]!
  skipDuplicates: Boolean
}

input FeedbackResponseCreateManyFeedbackInput {
  id: String
  openedDate: DateTime
  closedDate: DateTime
  routeOutside: Boolean
  resolved: Boolean
  reviewerId: String
  resolvedComment: String
}

input FeedbackCreateOrConnectWithoutOrgsInput {
  where: FeedbackWhereUniqueInput!
  create: FeedbackCreateWithoutOrgsInput!
}

input OrgCreateOrConnectWithoutChildrenInput {
  where: OrgWhereUniqueInput!
  create: OrgCreateWithoutChildrenInput!
}

input OrgCreateNestedManyWithoutParentInput {
  create: [OrgCreateWithoutParentInput!]
  connectOrCreate: [OrgCreateOrConnectWithoutParentInput!]
  createMany: OrgCreateManyParentInputEnvelope
  connect: [OrgWhereUniqueInput!]
}

input OrgCreateWithoutParentInput {
  id: String
  name: String!
  orgTier: OrgTier!
  users: UserCreateNestedManyWithoutOrgsInput
  children: OrgCreateNestedManyWithoutParentInput
  feedbacks: FeedbackCreateNestedManyWithoutOrgsInput
}

input OrgCreateOrConnectWithoutParentInput {
  where: OrgWhereUniqueInput!
  create: OrgCreateWithoutParentInput!
}

input OrgCreateManyParentInputEnvelope {
  data: [OrgCreateManyParentInput!]!
  skipDuplicates: Boolean
}

input OrgCreateManyParentInput {
  id: String
  name: String!
  orgTier: OrgTier!
}

input OrgCreateOrConnectWithoutUsersInput {
  where: OrgWhereUniqueInput!
  create: OrgCreateWithoutUsersInput!
}

input FeedbackResponseCreateNestedManyWithoutReviewedByInput {
  create: [FeedbackResponseCreateWithoutReviewedByInput!]
  connectOrCreate: [FeedbackResponseCreateOrConnectWithoutReviewedByInput!]
  createMany: FeedbackResponseCreateManyReviewedByInputEnvelope
  connect: [FeedbackResponseWhereUniqueInput!]
}

input FeedbackResponseCreateWithoutReviewedByInput {
  id: String
  feedback: FeedbackCreateNestedOneWithoutFeedbackResponsesInput!
  openedDate: DateTime
  closedDate: DateTime
  answers: AnswerCreateNestedManyWithoutFeedbackResponseInput
  routeOutside: Boolean
  tags: TagCreateNestedManyWithoutFeedbackResponsesInput
  comments: CommentCreateNestedManyWithoutFeedbackResponseInput
  resolved: Boolean
  resolvedComment: String
}

input FeedbackResponseCreateOrConnectWithoutReviewedByInput {
  where: FeedbackResponseWhereUniqueInput!
  create: FeedbackResponseCreateWithoutReviewedByInput!
}

input FeedbackResponseCreateManyReviewedByInputEnvelope {
  data: [FeedbackResponseCreateManyReviewedByInput!]!
  skipDuplicates: Boolean
}

input FeedbackResponseCreateManyReviewedByInput {
  id: String
  feedbackId: String!
  openedDate: DateTime
  closedDate: DateTime
  routeOutside: Boolean
  resolved: Boolean
  resolvedComment: String
}

input UserCreateOrConnectWithoutCommentsInput {
  where: UserWhereUniqueInput!
  create: UserCreateWithoutCommentsInput!
}

input AccountRequestCreateNestedOneWithoutCommentsInput {
  create: AccountRequestCreateWithoutCommentsInput
  connectOrCreate: AccountRequestCreateOrConnectWithoutCommentsInput
  connect: AccountRequestWhereUniqueInput
}

input AccountRequestCreateWithoutCommentsInput {
  id: String
  user: UserCreateNestedOneWithoutAccountRequestInput!
}

input UserCreateNestedOneWithoutAccountRequestInput {
  create: UserCreateWithoutAccountRequestInput
  connectOrCreate: UserCreateOrConnectWithoutAccountRequestInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutAccountRequestInput {
  id: String
  email: String!
  password: String!
  grade: String
  firstName: String!
  lastName: String!
  status: Status!
  role: Role!
  refreshToken: RefreshTokenCreateNestedOneWithoutUserInput
  orgs: OrgCreateNestedManyWithoutUsersInput
  comments: CommentCreateNestedManyWithoutAuthorInput
  reviewedResponses: FeedbackResponseCreateNestedManyWithoutReviewedByInput
}

input UserCreateOrConnectWithoutAccountRequestInput {
  where: UserWhereUniqueInput!
  create: UserCreateWithoutAccountRequestInput!
}

input AccountRequestCreateOrConnectWithoutCommentsInput {
  where: AccountRequestWhereUniqueInput!
  create: AccountRequestCreateWithoutCommentsInput!
}

input CommentCreateOrConnectWithoutFeedbackResponseInput {
  where: CommentWhereUniqueInput!
  create: CommentCreateWithoutFeedbackResponseInput!
}

input CommentCreateManyFeedbackResponseInputEnvelope {
  data: [CommentCreateManyFeedbackResponseInput!]!
  skipDuplicates: Boolean
}

input CommentCreateManyFeedbackResponseInput {
  id: String
  value: String!
  date: DateTime
  authorId: String!
  accountRequestId: String
}

input FeedbackResponseCreateOrConnectWithoutAnswersInput {
  where: FeedbackResponseWhereUniqueInput!
  create: FeedbackResponseCreateWithoutAnswersInput!
}

input AnswerCreateOrConnectWithoutQuestionInput {
  where: AnswerWhereUniqueInput!
  create: AnswerCreateWithoutQuestionInput!
}

input AnswerCreateManyQuestionInputEnvelope {
  data: [AnswerCreateManyQuestionInput!]!
  skipDuplicates: Boolean
}

input AnswerCreateManyQuestionInput {
  id: String
  value: String!
  feedbackResponseId: String!
}

input QuestionCreateOrConnectWithoutFeedbacksInput {
  where: QuestionWhereUniqueInput!
  create: QuestionCreateWithoutFeedbacksInput!
}

input FeedbackCreateOrConnectWithoutFeedbackResponsesInput {
  where: FeedbackWhereUniqueInput!
  create: FeedbackCreateWithoutFeedbackResponsesInput!
}

input FeedbackResponseCreateOrConnectWithoutCommentsInput {
  where: FeedbackResponseWhereUniqueInput!
  create: FeedbackResponseCreateWithoutCommentsInput!
}

input CommentCreateOrConnectWithoutAuthorInput {
  where: CommentWhereUniqueInput!
  create: CommentCreateWithoutAuthorInput!
}

input CommentCreateManyAuthorInputEnvelope {
  data: [CommentCreateManyAuthorInput!]!
  skipDuplicates: Boolean
}

input CommentCreateManyAuthorInput {
  id: String
  value: String!
  date: DateTime
  feedbackResponseId: String
  accountRequestId: String
}

input UserCreateOrConnectWithoutOrgsInput {
  where: UserWhereUniqueInput!
  create: UserCreateWithoutOrgsInput!
}

input OrgUpsertWithWhereUniqueWithoutFeedbacksInput {
  where: OrgWhereUniqueInput!
  update: OrgUpdateWithoutFeedbacksInput!
  create: OrgCreateWithoutFeedbacksInput!
}

input OrgUpdateWithoutFeedbacksInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  orgTier: EnumOrgTierFieldUpdateOperationsInput
  users: UserUpdateManyWithoutOrgsNestedInput
  parent: OrgUpdateOneWithoutChildrenNestedInput
  children: OrgUpdateManyWithoutParentNestedInput
}

input EnumOrgTierFieldUpdateOperationsInput {
  set: OrgTier
}

input UserUpdateManyWithoutOrgsNestedInput {
  create: [UserCreateWithoutOrgsInput!]
  connectOrCreate: [UserCreateOrConnectWithoutOrgsInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutOrgsInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutOrgsInput!]
  updateMany: [UserUpdateManyWithWhereWithoutOrgsInput!]
  deleteMany: [UserScalarWhereInput!]
}

input UserUpsertWithWhereUniqueWithoutOrgsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutOrgsInput!
  create: UserCreateWithoutOrgsInput!
}

input UserUpdateWithoutOrgsInput {
  id: StringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  grade: NullableStringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  status: EnumStatusFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  refreshToken: RefreshTokenUpdateOneWithoutUserNestedInput
  comments: CommentUpdateManyWithoutAuthorNestedInput
  reviewedResponses: FeedbackResponseUpdateManyWithoutReviewedByNestedInput
  accountRequest: AccountRequestUpdateOneWithoutUserNestedInput
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

input EnumStatusFieldUpdateOperationsInput {
  set: Status
}

input EnumRoleFieldUpdateOperationsInput {
  set: Role
}

input RefreshTokenUpdateOneWithoutUserNestedInput {
  create: RefreshTokenCreateWithoutUserInput
  connectOrCreate: RefreshTokenCreateOrConnectWithoutUserInput
  upsert: RefreshTokenUpsertWithoutUserInput
  disconnect: Boolean
  delete: Boolean
  connect: RefreshTokenWhereUniqueInput
  update: RefreshTokenUpdateWithoutUserInput
}

input RefreshTokenUpsertWithoutUserInput {
  update: RefreshTokenUpdateWithoutUserInput!
  create: RefreshTokenCreateWithoutUserInput!
}

input RefreshTokenUpdateWithoutUserInput {
  id: StringFieldUpdateOperationsInput
  isRevoked: BoolFieldUpdateOperationsInput
  issuedDate: DateTimeFieldUpdateOperationsInput
  expiredDate: DateTimeFieldUpdateOperationsInput
  hash: StringFieldUpdateOperationsInput
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input CommentUpdateManyWithoutAuthorNestedInput {
  create: [CommentCreateWithoutAuthorInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutAuthorInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutAuthorInput!]
  createMany: CommentCreateManyAuthorInputEnvelope
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [CommentUpdateManyWithWhereWithoutAuthorInput!]
  deleteMany: [CommentScalarWhereInput!]
}

input CommentUpsertWithWhereUniqueWithoutAuthorInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutAuthorInput!
  create: CommentCreateWithoutAuthorInput!
}

input CommentUpdateWithoutAuthorInput {
  id: StringFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  feedbackResponse: FeedbackResponseUpdateOneWithoutCommentsNestedInput
  accountRequest: AccountRequestUpdateOneWithoutCommentsNestedInput
}

input FeedbackResponseUpdateOneWithoutCommentsNestedInput {
  create: FeedbackResponseCreateWithoutCommentsInput
  connectOrCreate: FeedbackResponseCreateOrConnectWithoutCommentsInput
  upsert: FeedbackResponseUpsertWithoutCommentsInput
  disconnect: Boolean
  delete: Boolean
  connect: FeedbackResponseWhereUniqueInput
  update: FeedbackResponseUpdateWithoutCommentsInput
}

input FeedbackResponseUpsertWithoutCommentsInput {
  update: FeedbackResponseUpdateWithoutCommentsInput!
  create: FeedbackResponseCreateWithoutCommentsInput!
}

input FeedbackResponseUpdateWithoutCommentsInput {
  id: StringFieldUpdateOperationsInput
  feedback: FeedbackUpdateOneRequiredWithoutFeedbackResponsesNestedInput
  openedDate: DateTimeFieldUpdateOperationsInput
  closedDate: NullableDateTimeFieldUpdateOperationsInput
  answers: AnswerUpdateManyWithoutFeedbackResponseNestedInput
  routeOutside: BoolFieldUpdateOperationsInput
  tags: TagUpdateManyWithoutFeedbackResponsesNestedInput
  resolved: BoolFieldUpdateOperationsInput
  reviewedBy: UserUpdateOneWithoutReviewedResponsesNestedInput
  resolvedComment: NullableStringFieldUpdateOperationsInput
}

input FeedbackUpdateOneRequiredWithoutFeedbackResponsesNestedInput {
  create: FeedbackCreateWithoutFeedbackResponsesInput
  connectOrCreate: FeedbackCreateOrConnectWithoutFeedbackResponsesInput
  upsert: FeedbackUpsertWithoutFeedbackResponsesInput
  connect: FeedbackWhereUniqueInput
  update: FeedbackUpdateWithoutFeedbackResponsesInput
}

input FeedbackUpsertWithoutFeedbackResponsesInput {
  update: FeedbackUpdateWithoutFeedbackResponsesInput!
  create: FeedbackCreateWithoutFeedbackResponsesInput!
}

input FeedbackUpdateWithoutFeedbackResponsesInput {
  id: StringFieldUpdateOperationsInput
  orgs: OrgUpdateManyWithoutFeedbacksNestedInput
  questions: QuestionUpdateManyWithoutFeedbacksNestedInput
  questionsHash: NullableStringFieldUpdateOperationsInput
}

input QuestionUpdateManyWithoutFeedbacksNestedInput {
  create: [QuestionCreateWithoutFeedbacksInput!]
  connectOrCreate: [QuestionCreateOrConnectWithoutFeedbacksInput!]
  upsert: [QuestionUpsertWithWhereUniqueWithoutFeedbacksInput!]
  set: [QuestionWhereUniqueInput!]
  disconnect: [QuestionWhereUniqueInput!]
  delete: [QuestionWhereUniqueInput!]
  connect: [QuestionWhereUniqueInput!]
  update: [QuestionUpdateWithWhereUniqueWithoutFeedbacksInput!]
  updateMany: [QuestionUpdateManyWithWhereWithoutFeedbacksInput!]
  deleteMany: [QuestionScalarWhereInput!]
}

input QuestionUpsertWithWhereUniqueWithoutFeedbacksInput {
  where: QuestionWhereUniqueInput!
  update: QuestionUpdateWithoutFeedbacksInput!
  create: QuestionCreateWithoutFeedbacksInput!
}

input QuestionUpdateWithoutFeedbacksInput {
  id: StringFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
  answers: AnswerUpdateManyWithoutQuestionNestedInput
}

input AnswerUpdateManyWithoutQuestionNestedInput {
  create: [AnswerCreateWithoutQuestionInput!]
  connectOrCreate: [AnswerCreateOrConnectWithoutQuestionInput!]
  upsert: [AnswerUpsertWithWhereUniqueWithoutQuestionInput!]
  createMany: AnswerCreateManyQuestionInputEnvelope
  set: [AnswerWhereUniqueInput!]
  disconnect: [AnswerWhereUniqueInput!]
  delete: [AnswerWhereUniqueInput!]
  connect: [AnswerWhereUniqueInput!]
  update: [AnswerUpdateWithWhereUniqueWithoutQuestionInput!]
  updateMany: [AnswerUpdateManyWithWhereWithoutQuestionInput!]
  deleteMany: [AnswerScalarWhereInput!]
}

input AnswerUpsertWithWhereUniqueWithoutQuestionInput {
  where: AnswerWhereUniqueInput!
  update: AnswerUpdateWithoutQuestionInput!
  create: AnswerCreateWithoutQuestionInput!
}

input AnswerUpdateWithoutQuestionInput {
  id: StringFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
  feedbackResponse: FeedbackResponseUpdateOneRequiredWithoutAnswersNestedInput
}

input FeedbackResponseUpdateOneRequiredWithoutAnswersNestedInput {
  create: FeedbackResponseCreateWithoutAnswersInput
  connectOrCreate: FeedbackResponseCreateOrConnectWithoutAnswersInput
  upsert: FeedbackResponseUpsertWithoutAnswersInput
  connect: FeedbackResponseWhereUniqueInput
  update: FeedbackResponseUpdateWithoutAnswersInput
}

input FeedbackResponseUpsertWithoutAnswersInput {
  update: FeedbackResponseUpdateWithoutAnswersInput!
  create: FeedbackResponseCreateWithoutAnswersInput!
}

input FeedbackResponseUpdateWithoutAnswersInput {
  id: StringFieldUpdateOperationsInput
  feedback: FeedbackUpdateOneRequiredWithoutFeedbackResponsesNestedInput
  openedDate: DateTimeFieldUpdateOperationsInput
  closedDate: NullableDateTimeFieldUpdateOperationsInput
  routeOutside: BoolFieldUpdateOperationsInput
  tags: TagUpdateManyWithoutFeedbackResponsesNestedInput
  comments: CommentUpdateManyWithoutFeedbackResponseNestedInput
  resolved: BoolFieldUpdateOperationsInput
  reviewedBy: UserUpdateOneWithoutReviewedResponsesNestedInput
  resolvedComment: NullableStringFieldUpdateOperationsInput
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input TagUpdateManyWithoutFeedbackResponsesNestedInput {
  create: [TagCreateWithoutFeedbackResponsesInput!]
  connectOrCreate: [TagCreateOrConnectWithoutFeedbackResponsesInput!]
  upsert: [TagUpsertWithWhereUniqueWithoutFeedbackResponsesInput!]
  set: [TagWhereUniqueInput!]
  disconnect: [TagWhereUniqueInput!]
  delete: [TagWhereUniqueInput!]
  connect: [TagWhereUniqueInput!]
  update: [TagUpdateWithWhereUniqueWithoutFeedbackResponsesInput!]
  updateMany: [TagUpdateManyWithWhereWithoutFeedbackResponsesInput!]
  deleteMany: [TagScalarWhereInput!]
}

input TagUpsertWithWhereUniqueWithoutFeedbackResponsesInput {
  where: TagWhereUniqueInput!
  update: TagUpdateWithoutFeedbackResponsesInput!
  create: TagCreateWithoutFeedbackResponsesInput!
}

input TagUpdateWithoutFeedbackResponsesInput {
  id: StringFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
  type: EnumTagTypeFieldUpdateOperationsInput
}

input EnumTagTypeFieldUpdateOperationsInput {
  set: TagType
}

input TagUpdateWithWhereUniqueWithoutFeedbackResponsesInput {
  where: TagWhereUniqueInput!
  data: TagUpdateWithoutFeedbackResponsesInput!
}

input TagUpdateManyWithWhereWithoutFeedbackResponsesInput {
  where: TagScalarWhereInput!
  data: TagUpdateManyMutationInput!
}

input TagScalarWhereInput {
  AND: [TagScalarWhereInput!]
  OR: [TagScalarWhereInput!]
  NOT: [TagScalarWhereInput!]
  id: StringFilter
  value: StringFilter
  type: EnumTagTypeFilter
}

input TagUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
  type: EnumTagTypeFieldUpdateOperationsInput
}

input CommentUpdateManyWithoutFeedbackResponseNestedInput {
  create: [CommentCreateWithoutFeedbackResponseInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutFeedbackResponseInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutFeedbackResponseInput!]
  createMany: CommentCreateManyFeedbackResponseInputEnvelope
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutFeedbackResponseInput!]
  updateMany: [CommentUpdateManyWithWhereWithoutFeedbackResponseInput!]
  deleteMany: [CommentScalarWhereInput!]
}

input CommentUpsertWithWhereUniqueWithoutFeedbackResponseInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutFeedbackResponseInput!
  create: CommentCreateWithoutFeedbackResponseInput!
}

input CommentUpdateWithoutFeedbackResponseInput {
  id: StringFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  author: UserUpdateOneRequiredWithoutCommentsNestedInput
  accountRequest: AccountRequestUpdateOneWithoutCommentsNestedInput
}

input UserUpdateOneRequiredWithoutCommentsNestedInput {
  create: UserCreateWithoutCommentsInput
  connectOrCreate: UserCreateOrConnectWithoutCommentsInput
  upsert: UserUpsertWithoutCommentsInput
  connect: UserWhereUniqueInput
  update: UserUpdateWithoutCommentsInput
}

input UserUpsertWithoutCommentsInput {
  update: UserUpdateWithoutCommentsInput!
  create: UserCreateWithoutCommentsInput!
}

input UserUpdateWithoutCommentsInput {
  id: StringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  grade: NullableStringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  status: EnumStatusFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  refreshToken: RefreshTokenUpdateOneWithoutUserNestedInput
  orgs: OrgUpdateManyWithoutUsersNestedInput
  reviewedResponses: FeedbackResponseUpdateManyWithoutReviewedByNestedInput
  accountRequest: AccountRequestUpdateOneWithoutUserNestedInput
}

input OrgUpdateManyWithoutUsersNestedInput {
  create: [OrgCreateWithoutUsersInput!]
  connectOrCreate: [OrgCreateOrConnectWithoutUsersInput!]
  upsert: [OrgUpsertWithWhereUniqueWithoutUsersInput!]
  set: [OrgWhereUniqueInput!]
  disconnect: [OrgWhereUniqueInput!]
  delete: [OrgWhereUniqueInput!]
  connect: [OrgWhereUniqueInput!]
  update: [OrgUpdateWithWhereUniqueWithoutUsersInput!]
  updateMany: [OrgUpdateManyWithWhereWithoutUsersInput!]
  deleteMany: [OrgScalarWhereInput!]
}

input OrgUpsertWithWhereUniqueWithoutUsersInput {
  where: OrgWhereUniqueInput!
  update: OrgUpdateWithoutUsersInput!
  create: OrgCreateWithoutUsersInput!
}

input OrgUpdateWithoutUsersInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  orgTier: EnumOrgTierFieldUpdateOperationsInput
  parent: OrgUpdateOneWithoutChildrenNestedInput
  children: OrgUpdateManyWithoutParentNestedInput
  feedbacks: FeedbackUpdateManyWithoutOrgsNestedInput
}

input OrgUpdateOneWithoutChildrenNestedInput {
  create: OrgCreateWithoutChildrenInput
  connectOrCreate: OrgCreateOrConnectWithoutChildrenInput
  upsert: OrgUpsertWithoutChildrenInput
  disconnect: Boolean
  delete: Boolean
  connect: OrgWhereUniqueInput
  update: OrgUpdateWithoutChildrenInput
}

input OrgUpsertWithoutChildrenInput {
  update: OrgUpdateWithoutChildrenInput!
  create: OrgCreateWithoutChildrenInput!
}

input OrgUpdateWithoutChildrenInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  orgTier: EnumOrgTierFieldUpdateOperationsInput
  users: UserUpdateManyWithoutOrgsNestedInput
  parent: OrgUpdateOneWithoutChildrenNestedInput
  feedbacks: FeedbackUpdateManyWithoutOrgsNestedInput
}

input FeedbackUpdateManyWithoutOrgsNestedInput {
  create: [FeedbackCreateWithoutOrgsInput!]
  connectOrCreate: [FeedbackCreateOrConnectWithoutOrgsInput!]
  upsert: [FeedbackUpsertWithWhereUniqueWithoutOrgsInput!]
  set: [FeedbackWhereUniqueInput!]
  disconnect: [FeedbackWhereUniqueInput!]
  delete: [FeedbackWhereUniqueInput!]
  connect: [FeedbackWhereUniqueInput!]
  update: [FeedbackUpdateWithWhereUniqueWithoutOrgsInput!]
  updateMany: [FeedbackUpdateManyWithWhereWithoutOrgsInput!]
  deleteMany: [FeedbackScalarWhereInput!]
}

input FeedbackUpsertWithWhereUniqueWithoutOrgsInput {
  where: FeedbackWhereUniqueInput!
  update: FeedbackUpdateWithoutOrgsInput!
  create: FeedbackCreateWithoutOrgsInput!
}

input FeedbackUpdateWithoutOrgsInput {
  id: StringFieldUpdateOperationsInput
  questions: QuestionUpdateManyWithoutFeedbacksNestedInput
  questionsHash: NullableStringFieldUpdateOperationsInput
  feedbackResponses: FeedbackResponseUpdateManyWithoutFeedbackNestedInput
}

input FeedbackResponseUpdateManyWithoutFeedbackNestedInput {
  create: [FeedbackResponseCreateWithoutFeedbackInput!]
  connectOrCreate: [FeedbackResponseCreateOrConnectWithoutFeedbackInput!]
  upsert: [FeedbackResponseUpsertWithWhereUniqueWithoutFeedbackInput!]
  createMany: FeedbackResponseCreateManyFeedbackInputEnvelope
  set: [FeedbackResponseWhereUniqueInput!]
  disconnect: [FeedbackResponseWhereUniqueInput!]
  delete: [FeedbackResponseWhereUniqueInput!]
  connect: [FeedbackResponseWhereUniqueInput!]
  update: [FeedbackResponseUpdateWithWhereUniqueWithoutFeedbackInput!]
  updateMany: [FeedbackResponseUpdateManyWithWhereWithoutFeedbackInput!]
  deleteMany: [FeedbackResponseScalarWhereInput!]
}

input FeedbackResponseUpsertWithWhereUniqueWithoutFeedbackInput {
  where: FeedbackResponseWhereUniqueInput!
  update: FeedbackResponseUpdateWithoutFeedbackInput!
  create: FeedbackResponseCreateWithoutFeedbackInput!
}

input FeedbackResponseUpdateWithoutFeedbackInput {
  id: StringFieldUpdateOperationsInput
  openedDate: DateTimeFieldUpdateOperationsInput
  closedDate: NullableDateTimeFieldUpdateOperationsInput
  answers: AnswerUpdateManyWithoutFeedbackResponseNestedInput
  routeOutside: BoolFieldUpdateOperationsInput
  tags: TagUpdateManyWithoutFeedbackResponsesNestedInput
  comments: CommentUpdateManyWithoutFeedbackResponseNestedInput
  resolved: BoolFieldUpdateOperationsInput
  reviewedBy: UserUpdateOneWithoutReviewedResponsesNestedInput
  resolvedComment: NullableStringFieldUpdateOperationsInput
}

input AnswerUpdateManyWithoutFeedbackResponseNestedInput {
  create: [AnswerCreateWithoutFeedbackResponseInput!]
  connectOrCreate: [AnswerCreateOrConnectWithoutFeedbackResponseInput!]
  upsert: [AnswerUpsertWithWhereUniqueWithoutFeedbackResponseInput!]
  createMany: AnswerCreateManyFeedbackResponseInputEnvelope
  set: [AnswerWhereUniqueInput!]
  disconnect: [AnswerWhereUniqueInput!]
  delete: [AnswerWhereUniqueInput!]
  connect: [AnswerWhereUniqueInput!]
  update: [AnswerUpdateWithWhereUniqueWithoutFeedbackResponseInput!]
  updateMany: [AnswerUpdateManyWithWhereWithoutFeedbackResponseInput!]
  deleteMany: [AnswerScalarWhereInput!]
}

input AnswerUpsertWithWhereUniqueWithoutFeedbackResponseInput {
  where: AnswerWhereUniqueInput!
  update: AnswerUpdateWithoutFeedbackResponseInput!
  create: AnswerCreateWithoutFeedbackResponseInput!
}

input AnswerUpdateWithoutFeedbackResponseInput {
  id: StringFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
  question: QuestionUpdateOneRequiredWithoutAnswersNestedInput
}

input QuestionUpdateOneRequiredWithoutAnswersNestedInput {
  create: QuestionCreateWithoutAnswersInput
  connectOrCreate: QuestionCreateOrConnectWithoutAnswersInput
  upsert: QuestionUpsertWithoutAnswersInput
  connect: QuestionWhereUniqueInput
  update: QuestionUpdateWithoutAnswersInput
}

input QuestionUpsertWithoutAnswersInput {
  update: QuestionUpdateWithoutAnswersInput!
  create: QuestionCreateWithoutAnswersInput!
}

input QuestionUpdateWithoutAnswersInput {
  id: StringFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
  feedbacks: FeedbackUpdateManyWithoutQuestionsNestedInput
}

input FeedbackUpdateManyWithoutQuestionsNestedInput {
  create: [FeedbackCreateWithoutQuestionsInput!]
  connectOrCreate: [FeedbackCreateOrConnectWithoutQuestionsInput!]
  upsert: [FeedbackUpsertWithWhereUniqueWithoutQuestionsInput!]
  set: [FeedbackWhereUniqueInput!]
  disconnect: [FeedbackWhereUniqueInput!]
  delete: [FeedbackWhereUniqueInput!]
  connect: [FeedbackWhereUniqueInput!]
  update: [FeedbackUpdateWithWhereUniqueWithoutQuestionsInput!]
  updateMany: [FeedbackUpdateManyWithWhereWithoutQuestionsInput!]
  deleteMany: [FeedbackScalarWhereInput!]
}

input FeedbackUpsertWithWhereUniqueWithoutQuestionsInput {
  where: FeedbackWhereUniqueInput!
  update: FeedbackUpdateWithoutQuestionsInput!
  create: FeedbackCreateWithoutQuestionsInput!
}

input FeedbackUpdateWithoutQuestionsInput {
  id: StringFieldUpdateOperationsInput
  orgs: OrgUpdateManyWithoutFeedbacksNestedInput
  questionsHash: NullableStringFieldUpdateOperationsInput
  feedbackResponses: FeedbackResponseUpdateManyWithoutFeedbackNestedInput
}

input FeedbackUpdateWithWhereUniqueWithoutQuestionsInput {
  where: FeedbackWhereUniqueInput!
  data: FeedbackUpdateWithoutQuestionsInput!
}

input FeedbackUpdateManyWithWhereWithoutQuestionsInput {
  where: FeedbackScalarWhereInput!
  data: FeedbackUpdateManyMutationInput!
}

input FeedbackScalarWhereInput {
  AND: [FeedbackScalarWhereInput!]
  OR: [FeedbackScalarWhereInput!]
  NOT: [FeedbackScalarWhereInput!]
  id: StringFilter
  questionsHash: StringNullableFilter
}

input FeedbackUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  questionsHash: NullableStringFieldUpdateOperationsInput
}

input AnswerUpdateWithWhereUniqueWithoutFeedbackResponseInput {
  where: AnswerWhereUniqueInput!
  data: AnswerUpdateWithoutFeedbackResponseInput!
}

input AnswerUpdateManyWithWhereWithoutFeedbackResponseInput {
  where: AnswerScalarWhereInput!
  data: AnswerUpdateManyMutationInput!
}

input AnswerScalarWhereInput {
  AND: [AnswerScalarWhereInput!]
  OR: [AnswerScalarWhereInput!]
  NOT: [AnswerScalarWhereInput!]
  id: StringFilter
  value: StringFilter
  questionId: StringFilter
  feedbackResponseId: StringFilter
}

input AnswerUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
}

input UserUpdateOneWithoutReviewedResponsesNestedInput {
  create: UserCreateWithoutReviewedResponsesInput
  connectOrCreate: UserCreateOrConnectWithoutReviewedResponsesInput
  upsert: UserUpsertWithoutReviewedResponsesInput
  disconnect: Boolean
  delete: Boolean
  connect: UserWhereUniqueInput
  update: UserUpdateWithoutReviewedResponsesInput
}

input UserUpsertWithoutReviewedResponsesInput {
  update: UserUpdateWithoutReviewedResponsesInput!
  create: UserCreateWithoutReviewedResponsesInput!
}

input UserUpdateWithoutReviewedResponsesInput {
  id: StringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  grade: NullableStringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  status: EnumStatusFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  refreshToken: RefreshTokenUpdateOneWithoutUserNestedInput
  orgs: OrgUpdateManyWithoutUsersNestedInput
  comments: CommentUpdateManyWithoutAuthorNestedInput
  accountRequest: AccountRequestUpdateOneWithoutUserNestedInput
}

input AccountRequestUpdateOneWithoutUserNestedInput {
  create: AccountRequestCreateWithoutUserInput
  connectOrCreate: AccountRequestCreateOrConnectWithoutUserInput
  upsert: AccountRequestUpsertWithoutUserInput
  disconnect: Boolean
  delete: Boolean
  connect: AccountRequestWhereUniqueInput
  update: AccountRequestUpdateWithoutUserInput
}

input AccountRequestUpsertWithoutUserInput {
  update: AccountRequestUpdateWithoutUserInput!
  create: AccountRequestCreateWithoutUserInput!
}

input AccountRequestUpdateWithoutUserInput {
  id: StringFieldUpdateOperationsInput
  comments: CommentUpdateManyWithoutAccountRequestNestedInput
}

input CommentUpdateManyWithoutAccountRequestNestedInput {
  create: [CommentCreateWithoutAccountRequestInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutAccountRequestInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutAccountRequestInput!]
  createMany: CommentCreateManyAccountRequestInputEnvelope
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutAccountRequestInput!]
  updateMany: [CommentUpdateManyWithWhereWithoutAccountRequestInput!]
  deleteMany: [CommentScalarWhereInput!]
}

input CommentUpsertWithWhereUniqueWithoutAccountRequestInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutAccountRequestInput!
  create: CommentCreateWithoutAccountRequestInput!
}

input CommentUpdateWithoutAccountRequestInput {
  id: StringFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  author: UserUpdateOneRequiredWithoutCommentsNestedInput
  feedbackResponse: FeedbackResponseUpdateOneWithoutCommentsNestedInput
}

input CommentUpdateWithWhereUniqueWithoutAccountRequestInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutAccountRequestInput!
}

input CommentUpdateManyWithWhereWithoutAccountRequestInput {
  where: CommentScalarWhereInput!
  data: CommentUpdateManyMutationInput!
}

input CommentScalarWhereInput {
  AND: [CommentScalarWhereInput!]
  OR: [CommentScalarWhereInput!]
  NOT: [CommentScalarWhereInput!]
  id: StringFilter
  value: StringFilter
  date: DateTimeFilter
  authorId: StringFilter
  feedbackResponseId: StringNullableFilter
  accountRequestId: StringNullableFilter
}

input CommentUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
}

input FeedbackResponseUpdateWithWhereUniqueWithoutFeedbackInput {
  where: FeedbackResponseWhereUniqueInput!
  data: FeedbackResponseUpdateWithoutFeedbackInput!
}

input FeedbackResponseUpdateManyWithWhereWithoutFeedbackInput {
  where: FeedbackResponseScalarWhereInput!
  data: FeedbackResponseUpdateManyMutationInput!
}

input FeedbackResponseScalarWhereInput {
  AND: [FeedbackResponseScalarWhereInput!]
  OR: [FeedbackResponseScalarWhereInput!]
  NOT: [FeedbackResponseScalarWhereInput!]
  id: StringFilter
  feedbackId: StringFilter
  openedDate: DateTimeFilter
  closedDate: DateTimeNullableFilter
  routeOutside: BoolFilter
  resolved: BoolFilter
  reviewerId: StringNullableFilter
  resolvedComment: StringNullableFilter
}

input FeedbackResponseUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  openedDate: DateTimeFieldUpdateOperationsInput
  closedDate: NullableDateTimeFieldUpdateOperationsInput
  routeOutside: BoolFieldUpdateOperationsInput
  resolved: BoolFieldUpdateOperationsInput
  resolvedComment: NullableStringFieldUpdateOperationsInput
}

input FeedbackUpdateWithWhereUniqueWithoutOrgsInput {
  where: FeedbackWhereUniqueInput!
  data: FeedbackUpdateWithoutOrgsInput!
}

input FeedbackUpdateManyWithWhereWithoutOrgsInput {
  where: FeedbackScalarWhereInput!
  data: FeedbackUpdateManyMutationInput!
}

input OrgUpdateManyWithoutParentNestedInput {
  create: [OrgCreateWithoutParentInput!]
  connectOrCreate: [OrgCreateOrConnectWithoutParentInput!]
  upsert: [OrgUpsertWithWhereUniqueWithoutParentInput!]
  createMany: OrgCreateManyParentInputEnvelope
  set: [OrgWhereUniqueInput!]
  disconnect: [OrgWhereUniqueInput!]
  delete: [OrgWhereUniqueInput!]
  connect: [OrgWhereUniqueInput!]
  update: [OrgUpdateWithWhereUniqueWithoutParentInput!]
  updateMany: [OrgUpdateManyWithWhereWithoutParentInput!]
  deleteMany: [OrgScalarWhereInput!]
}

input OrgUpsertWithWhereUniqueWithoutParentInput {
  where: OrgWhereUniqueInput!
  update: OrgUpdateWithoutParentInput!
  create: OrgCreateWithoutParentInput!
}

input OrgUpdateWithoutParentInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  orgTier: EnumOrgTierFieldUpdateOperationsInput
  users: UserUpdateManyWithoutOrgsNestedInput
  children: OrgUpdateManyWithoutParentNestedInput
  feedbacks: FeedbackUpdateManyWithoutOrgsNestedInput
}

input OrgUpdateWithWhereUniqueWithoutParentInput {
  where: OrgWhereUniqueInput!
  data: OrgUpdateWithoutParentInput!
}

input OrgUpdateManyWithWhereWithoutParentInput {
  where: OrgScalarWhereInput!
  data: OrgUpdateManyMutationInput!
}

input OrgScalarWhereInput {
  AND: [OrgScalarWhereInput!]
  OR: [OrgScalarWhereInput!]
  NOT: [OrgScalarWhereInput!]
  id: StringFilter
  name: StringFilter
  orgTier: EnumOrgTierFilter
  parentId: StringNullableFilter
}

input OrgUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  orgTier: EnumOrgTierFieldUpdateOperationsInput
}

input OrgUpdateWithWhereUniqueWithoutUsersInput {
  where: OrgWhereUniqueInput!
  data: OrgUpdateWithoutUsersInput!
}

input OrgUpdateManyWithWhereWithoutUsersInput {
  where: OrgScalarWhereInput!
  data: OrgUpdateManyMutationInput!
}

input FeedbackResponseUpdateManyWithoutReviewedByNestedInput {
  create: [FeedbackResponseCreateWithoutReviewedByInput!]
  connectOrCreate: [FeedbackResponseCreateOrConnectWithoutReviewedByInput!]
  upsert: [FeedbackResponseUpsertWithWhereUniqueWithoutReviewedByInput!]
  createMany: FeedbackResponseCreateManyReviewedByInputEnvelope
  set: [FeedbackResponseWhereUniqueInput!]
  disconnect: [FeedbackResponseWhereUniqueInput!]
  delete: [FeedbackResponseWhereUniqueInput!]
  connect: [FeedbackResponseWhereUniqueInput!]
  update: [FeedbackResponseUpdateWithWhereUniqueWithoutReviewedByInput!]
  updateMany: [FeedbackResponseUpdateManyWithWhereWithoutReviewedByInput!]
  deleteMany: [FeedbackResponseScalarWhereInput!]
}

input FeedbackResponseUpsertWithWhereUniqueWithoutReviewedByInput {
  where: FeedbackResponseWhereUniqueInput!
  update: FeedbackResponseUpdateWithoutReviewedByInput!
  create: FeedbackResponseCreateWithoutReviewedByInput!
}

input FeedbackResponseUpdateWithoutReviewedByInput {
  id: StringFieldUpdateOperationsInput
  feedback: FeedbackUpdateOneRequiredWithoutFeedbackResponsesNestedInput
  openedDate: DateTimeFieldUpdateOperationsInput
  closedDate: NullableDateTimeFieldUpdateOperationsInput
  answers: AnswerUpdateManyWithoutFeedbackResponseNestedInput
  routeOutside: BoolFieldUpdateOperationsInput
  tags: TagUpdateManyWithoutFeedbackResponsesNestedInput
  comments: CommentUpdateManyWithoutFeedbackResponseNestedInput
  resolved: BoolFieldUpdateOperationsInput
  resolvedComment: NullableStringFieldUpdateOperationsInput
}

input FeedbackResponseUpdateWithWhereUniqueWithoutReviewedByInput {
  where: FeedbackResponseWhereUniqueInput!
  data: FeedbackResponseUpdateWithoutReviewedByInput!
}

input FeedbackResponseUpdateManyWithWhereWithoutReviewedByInput {
  where: FeedbackResponseScalarWhereInput!
  data: FeedbackResponseUpdateManyMutationInput!
}

input AccountRequestUpdateOneWithoutCommentsNestedInput {
  create: AccountRequestCreateWithoutCommentsInput
  connectOrCreate: AccountRequestCreateOrConnectWithoutCommentsInput
  upsert: AccountRequestUpsertWithoutCommentsInput
  disconnect: Boolean
  delete: Boolean
  connect: AccountRequestWhereUniqueInput
  update: AccountRequestUpdateWithoutCommentsInput
}

input AccountRequestUpsertWithoutCommentsInput {
  update: AccountRequestUpdateWithoutCommentsInput!
  create: AccountRequestCreateWithoutCommentsInput!
}

input AccountRequestUpdateWithoutCommentsInput {
  id: StringFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutAccountRequestNestedInput
}

input UserUpdateOneRequiredWithoutAccountRequestNestedInput {
  create: UserCreateWithoutAccountRequestInput
  connectOrCreate: UserCreateOrConnectWithoutAccountRequestInput
  upsert: UserUpsertWithoutAccountRequestInput
  connect: UserWhereUniqueInput
  update: UserUpdateWithoutAccountRequestInput
}

input UserUpsertWithoutAccountRequestInput {
  update: UserUpdateWithoutAccountRequestInput!
  create: UserCreateWithoutAccountRequestInput!
}

input UserUpdateWithoutAccountRequestInput {
  id: StringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  grade: NullableStringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  status: EnumStatusFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  refreshToken: RefreshTokenUpdateOneWithoutUserNestedInput
  orgs: OrgUpdateManyWithoutUsersNestedInput
  comments: CommentUpdateManyWithoutAuthorNestedInput
  reviewedResponses: FeedbackResponseUpdateManyWithoutReviewedByNestedInput
}

input CommentUpdateWithWhereUniqueWithoutFeedbackResponseInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutFeedbackResponseInput!
}

input CommentUpdateManyWithWhereWithoutFeedbackResponseInput {
  where: CommentScalarWhereInput!
  data: CommentUpdateManyMutationInput!
}

input AnswerUpdateWithWhereUniqueWithoutQuestionInput {
  where: AnswerWhereUniqueInput!
  data: AnswerUpdateWithoutQuestionInput!
}

input AnswerUpdateManyWithWhereWithoutQuestionInput {
  where: AnswerScalarWhereInput!
  data: AnswerUpdateManyMutationInput!
}

input QuestionUpdateWithWhereUniqueWithoutFeedbacksInput {
  where: QuestionWhereUniqueInput!
  data: QuestionUpdateWithoutFeedbacksInput!
}

input QuestionUpdateManyWithWhereWithoutFeedbacksInput {
  where: QuestionScalarWhereInput!
  data: QuestionUpdateManyMutationInput!
}

input QuestionScalarWhereInput {
  AND: [QuestionScalarWhereInput!]
  OR: [QuestionScalarWhereInput!]
  NOT: [QuestionScalarWhereInput!]
  id: StringFilter
  value: StringFilter
}

input QuestionUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
}

input CommentUpdateWithWhereUniqueWithoutAuthorInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutAuthorInput!
}

input CommentUpdateManyWithWhereWithoutAuthorInput {
  where: CommentScalarWhereInput!
  data: CommentUpdateManyMutationInput!
}

input UserUpdateWithWhereUniqueWithoutOrgsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutOrgsInput!
}

input UserUpdateManyWithWhereWithoutOrgsInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyMutationInput!
}

input UserScalarWhereInput {
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
  id: StringFilter
  email: StringFilter
  password: StringFilter
  grade: StringNullableFilter
  firstName: StringFilter
  lastName: StringFilter
  status: EnumStatusFilter
  role: EnumRoleFilter
}

input UserUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  grade: NullableStringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  status: EnumStatusFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
}

input OrgUpdateWithWhereUniqueWithoutFeedbacksInput {
  where: OrgWhereUniqueInput!
  data: OrgUpdateWithoutFeedbacksInput!
}

input OrgUpdateManyWithWhereWithoutFeedbacksInput {
  where: OrgScalarWhereInput!
  data: OrgUpdateManyMutationInput!
}

input AccountRequestUpdateInput {
  id: StringFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutAccountRequestNestedInput
  comments: CommentUpdateManyWithoutAccountRequestNestedInput
}

input FeedbackResponseCreateInput {
  id: String
  feedback: FeedbackCreateNestedOneWithoutFeedbackResponsesInput!
  openedDate: DateTime
  closedDate: DateTime
  answers: AnswerCreateNestedManyWithoutFeedbackResponseInput
  routeOutside: Boolean
  tags: TagCreateNestedManyWithoutFeedbackResponsesInput
  comments: CommentCreateNestedManyWithoutFeedbackResponseInput
  resolved: Boolean
  reviewedBy: UserCreateNestedOneWithoutReviewedResponsesInput
  resolvedComment: String
}

input FeedbackResponseUpdateInput {
  id: StringFieldUpdateOperationsInput
  feedback: FeedbackUpdateOneRequiredWithoutFeedbackResponsesNestedInput
  openedDate: DateTimeFieldUpdateOperationsInput
  closedDate: NullableDateTimeFieldUpdateOperationsInput
  answers: AnswerUpdateManyWithoutFeedbackResponseNestedInput
  routeOutside: BoolFieldUpdateOperationsInput
  tags: TagUpdateManyWithoutFeedbackResponsesNestedInput
  comments: CommentUpdateManyWithoutFeedbackResponseNestedInput
  resolved: BoolFieldUpdateOperationsInput
  reviewedBy: UserUpdateOneWithoutReviewedResponsesNestedInput
  resolvedComment: NullableStringFieldUpdateOperationsInput
}

input OrgCreateInput {
  id: String
  name: String!
  orgTier: OrgTier!
  users: UserCreateNestedManyWithoutOrgsInput
  parent: OrgCreateNestedOneWithoutChildrenInput
  children: OrgCreateNestedManyWithoutParentInput
  feedbacks: FeedbackCreateNestedManyWithoutOrgsInput
}

input OrgUpdateInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  orgTier: EnumOrgTierFieldUpdateOperationsInput
  users: UserUpdateManyWithoutOrgsNestedInput
  parent: OrgUpdateOneWithoutChildrenNestedInput
  children: OrgUpdateManyWithoutParentNestedInput
  feedbacks: FeedbackUpdateManyWithoutOrgsNestedInput
}

input UserCreateInput {
  id: String
  email: String!
  password: String!
  grade: String
  firstName: String!
  lastName: String!
  status: Status!
  role: Role!
  refreshToken: RefreshTokenCreateNestedOneWithoutUserInput
  orgs: OrgCreateNestedManyWithoutUsersInput
  comments: CommentCreateNestedManyWithoutAuthorInput
  reviewedResponses: FeedbackResponseCreateNestedManyWithoutReviewedByInput
  accountRequest: AccountRequestCreateNestedOneWithoutUserInput
}

input LoginUserInput {
  username: String!
  password: String!
}

input RefreshLoginInput {
  refreshToken: String!
}